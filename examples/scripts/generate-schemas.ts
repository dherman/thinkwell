#!/usr/bin/env npx tsx
/**
 * Script to generate JSON schemas from TypeScript types using ts-json-schema-generator.
 *
 * This script:
 * 1. Reads the types from 04-types.ts
 * 2. Generates JSON schemas for each exported interface
 * 3. Writes a TypeScript module that exports SchemaProvider<T> instances
 *
 * Usage:
 *   pnpm generate:schemas
 */

import { execSync } from "node:child_process";
import { writeFileSync } from "node:fs";
import { dirname, join } from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = dirname(fileURLToPath(import.meta.url));
const projectRoot = join(__dirname, "..");

// Types to generate schemas for (in order)
const types = ["Summary", "AnalysisResult", "Topic", "Config", "UserProfile"];

// Generate schema for a single type
function generateSchema(typeName: string): object {
  const cmd = [
    "npx",
    "ts-json-schema-generator",
    "--path",
    "src/04-types.ts",
    "--type",
    typeName,
    "--tsconfig",
    "tsconfig.json",
    "--no-ref-encode",
  ].join(" ");

  const output = execSync(cmd, { cwd: projectRoot, encoding: "utf-8" });
  const schema = JSON.parse(output);
  const definitions = schema.definitions || {};

  // Extract the type definition from the schema
  // ts-json-schema-generator wraps it in $ref and definitions
  let result = definitions[typeName] || schema;

  // Inline $ref references to make schemas self-contained
  result = inlineRefs(result, definitions);

  return result;
}

// Recursively inline $ref references
function inlineRefs(
  obj: unknown,
  definitions: Record<string, object>
): unknown {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map((item) => inlineRefs(item, definitions));
  }

  const record = obj as Record<string, unknown>;

  // If this object has a $ref, replace it with the referenced definition
  if (typeof record["$ref"] === "string") {
    const ref = record["$ref"];
    const match = ref.match(/^#\/definitions\/(.+)$/);
    if (match && definitions[match[1]]) {
      return inlineRefs(definitions[match[1]], definitions);
    }
  }

  // Otherwise, recursively process all properties
  const result: Record<string, unknown> = {};
  for (const [key, value] of Object.entries(record)) {
    result[key] = inlineRefs(value, definitions);
  }
  return result;
}

// Generate the TypeScript module
function generateModule(): string {
  const schemas: Record<string, object> = {};

  console.log("Generating schemas...");
  for (const typeName of types) {
    console.log(`  - ${typeName}`);
    schemas[typeName] = generateSchema(typeName);
  }

  // Build the module content
  const lines: string[] = [
    "/**",
    " * AUTO-GENERATED FILE - DO NOT EDIT",
    " *",
    " * Generated by: pnpm generate:schemas",
    " * Source: src/04-types.ts",
    " *",
    " * This file contains JSON schemas generated from TypeScript types",
    " * using ts-json-schema-generator. Re-run the generator if you",
    " * modify the source types.",
    " */",
    "",
    'import type { SchemaProvider, JsonSchema } from "@dherman/sacp";',
    "import type {",
    ...types.map((t) => `  ${t},`),
    '} from "./04-types.js";',
    "",
    "/**",
    " * Creates a SchemaProvider<T> from a raw JSON schema object.",
    " */",
    "function schemaProvider<T>(schema: Record<string, unknown>): SchemaProvider<T> {",
    "  return {",
    "    toJsonSchema: () => schema as JsonSchema,",
    "  };",
    "}",
    "",
  ];

  // Add each schema
  for (const typeName of types) {
    const schema = schemas[typeName];
    const schemaJson = JSON.stringify(schema, null, 2)
      .split("\n")
      .map((line, i) => (i === 0 ? line : "  " + line))
      .join("\n");

    lines.push(
      "/**",
      ` * SchemaProvider for ${typeName} type.`,
      " * @generated",
      " */",
      `export const ${typeName}Schema: SchemaProvider<${typeName}> = schemaProvider<${typeName}>(${schemaJson});`,
      ""
    );
  }

  return lines.join("\n");
}

// Main
const outputPath = join(projectRoot, "src", "04-types.schemas.generated.ts");
const content = generateModule();
writeFileSync(outputPath, content);
console.log(`\nWritten to: ${outputPath}`);
