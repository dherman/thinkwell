import { describe, it } from "node:test";
import assert from "node:assert";
import type { Summary, AnalysisResult, Config, UserProfile } from "./generator.types.js";
import {
  SummarySchema,
  AnalysisResultSchema,
  ConfigSchema,
  UserProfileSchema,
} from "./generator.schemas.js";

/**
 * These tests verify that the auto-generated schemas correctly
 * represent the TypeScript types from generator.types.ts.
 *
 * The schemas are generated by: pnpm generate:schemas
 * which runs ts-json-schema-generator on the source types.
 *
 * In a real project, you would:
 * 1. Run pnpm generate:schemas during your build step
 * 2. Commit the generated file or regenerate in CI
 * 3. Use these tests to verify the schemas match expectations
 */

describe("Example 4: Build-time generated schemas", () => {
  describe("SummarySchema", () => {
    it("should produce valid JSON Schema", () => {
      const schema = SummarySchema.toJsonSchema();

      assert.strictEqual(schema.type, "object");
      assert.ok(schema.properties);
      assert.ok(Array.isArray(schema.required));
      assert.ok((schema.required as string[]).includes("title"));
      assert.ok((schema.required as string[]).includes("points"));
      assert.ok((schema.required as string[]).includes("wordCount"));
    });

    it("should have correct property types matching TypeScript interface", () => {
      const schema = SummarySchema.toJsonSchema();
      const props = schema.properties!;

      assert.strictEqual(props.title.type, "string");
      assert.strictEqual(props.points.type, "array");
      assert.strictEqual(props.points.items?.type, "string");
      assert.strictEqual(props.wordCount.type, "number");
    });

    it("should include minimum constraint from JSDoc", () => {
      const schema = SummarySchema.toJsonSchema();
      const props = schema.properties!;

      assert.strictEqual(props.wordCount.minimum, 0);
    });

    it("should preserve descriptions from JSDoc", () => {
      const schema = SummarySchema.toJsonSchema();
      const props = schema.properties!;

      assert.strictEqual(props.title.description, "A brief title for the summary");
      assert.strictEqual(props.points.description, "Key points from the content");
    });

    it("should type-check against hand-written interface", () => {
      // This is a compile-time check: if the schema provider
      // doesn't match the Summary type, TypeScript will error
      const _provider: typeof SummarySchema = SummarySchema;

      // Simulate what patchwork.think() would return
      const mockResult: Summary = {
        title: "Test",
        points: ["point 1"],
        wordCount: 100,
      };

      assert.ok(mockResult.title);
    });
  });

  describe("AnalysisResultSchema", () => {
    it("should handle enum types", () => {
      const schema = AnalysisResultSchema.toJsonSchema();
      const sentimentSchema = schema.properties?.sentiment;

      assert.ok(sentimentSchema?.enum);
      assert.ok(sentimentSchema.enum.includes("positive"));
      assert.ok(sentimentSchema.enum.includes("negative"));
      assert.ok(sentimentSchema.enum.includes("neutral"));
    });

    it("should handle nested object arrays", () => {
      const schema = AnalysisResultSchema.toJsonSchema();
      const topicsSchema = schema.properties?.topics;

      assert.strictEqual(topicsSchema?.type, "array");
      assert.ok(topicsSchema?.items);
      assert.strictEqual(topicsSchema.items?.type, "object");
    });

    it("should include numeric constraints from JSDoc", () => {
      const schema = AnalysisResultSchema.toJsonSchema();

      assert.strictEqual(schema.properties?.confidence.minimum, 0);
      assert.strictEqual(schema.properties?.confidence.maximum, 1);
    });
  });

  describe("ConfigSchema", () => {
    it("should handle optional fields", () => {
      const schema = ConfigSchema.toJsonSchema();
      const required = schema.required as string[] | undefined;

      // All fields are optional in Config, so required should be empty or undefined
      assert.ok(!required || required.length === 0);
    });

    it("should include default value from JSDoc", () => {
      const schema = ConfigSchema.toJsonSchema();

      assert.strictEqual(schema.properties?.temperature.default, 0.7);
    });

    it("should include numeric constraints on temperature", () => {
      const schema = ConfigSchema.toJsonSchema();

      assert.strictEqual(schema.properties?.temperature.minimum, 0);
      assert.strictEqual(schema.properties?.temperature.maximum, 2);
    });
  });

  describe("UserProfileSchema", () => {
    it("should include format specifications from JSDoc", () => {
      const schema = UserProfileSchema.toJsonSchema();

      assert.strictEqual(schema.properties?.id.format, "uuid");
      assert.strictEqual(schema.properties?.email.format, "email");
      assert.strictEqual(schema.properties?.website.format, "uri");
      assert.strictEqual(schema.properties?.createdAt.format, "date-time");
    });

    it("should mark optional fields correctly", () => {
      const schema = UserProfileSchema.toJsonSchema();
      const required = schema.required as string[];

      assert.ok(required.includes("id"));
      assert.ok(required.includes("email"));
      assert.ok(required.includes("createdAt"));
      assert.ok(!required.includes("website"));
    });
  });

  describe("Type-first workflow", () => {
    it("should maintain type safety between source types and schemas", () => {
      const jsonSchema = SummarySchema.toJsonSchema();
      assert.ok(jsonSchema);

      const verifyType = <T>(_schema: { toJsonSchema(): unknown }): T => {
        return {} as T;
      };

      const result: Summary = verifyType<Summary>(SummarySchema);
      assert.ok(result !== undefined);
    });

    it("should demonstrate clean separation of concerns", () => {
      // generator.types.ts: Hand-written types with JSDoc annotations (source of truth)
      // 04-types.schemas.generated.ts: Auto-generated by pnpm generate:schemas
      //
      // The SchemaProvider<T> interface bridges these:
      // - T comes from generator.types.ts (hand-written)
      // - toJsonSchema() returns the auto-generated schema

      const validateStructure = (schema: { toJsonSchema(): unknown }) => {
        const json = schema.toJsonSchema() as Record<string, unknown>;
        return json.type === "object" && json.properties !== undefined;
      };

      assert.ok(validateStructure(SummarySchema));
      assert.ok(validateStructure(AnalysisResultSchema));
      assert.ok(validateStructure(ConfigSchema));
      assert.ok(validateStructure(UserProfileSchema));
    });
  });
});
