/**
 * Generator for ambient .d.ts files that provide IDE support for
 * auto-generated Schema namespaces.
 *
 * When a TypeScript file contains `@JSONSchema` marked types, this module
 * generates a companion `.thinkwell.d.ts` file that declares the namespace
 * augmentation. This allows IDEs to provide autocomplete and type checking
 * for `TypeName.Schema` without running the Bun plugin.
 *
 * @example
 * ```typescript
 * // greeting.ts
 * /** @JSONSchema *\/
 * export interface Greeting {
 *   message: string;
 * }
 *
 * // greeting.thinkwell.d.ts (auto-generated)
 * import type { SchemaProvider } from "@thinkwell/acp";
 * import type { Greeting } from "./greeting.js";
 *
 * declare namespace Greeting {
 *   export const Schema: SchemaProvider<Greeting>;
 * }
 * ```
 */

import { dirname, basename, relative, resolve } from "path";
import type { TypeInfo } from "./transform.js";
import { FileReadError, FileWriteError, DeclarationGenerationError } from "./errors.js";

/**
 * Generate the content of an ambient declaration file for the given types.
 *
 * @param sourceFile - The path to the source .ts file
 * @param types - The types marked with @JSONSchema in that file
 * @returns The content of the .d.ts file
 */
export function generateDeclarationContent(
  sourceFile: string,
  types: TypeInfo[]
): string {
  if (types.length === 0) {
    return "";
  }

  const lines: string[] = [
    "// Auto-generated by @thinkwell/bun-plugin",
    "// This file provides IDE support for auto-generated Schema namespaces.",
    "// Do not edit manually - changes will be overwritten.",
    "",
    'import type { SchemaProvider } from "@thinkwell/acp";',
  ];

  // Import the types from the source file
  // Use .js extension for ESM compatibility
  const sourceBasename = basename(sourceFile, ".ts").replace(/\.tsx$/, "");
  const importPath = `./${sourceBasename}.js`;

  const typeNames = types.map((t) => t.name);
  lines.push(`import type { ${typeNames.join(", ")} } from "${importPath}";`);
  lines.push("");

  // Generate namespace declarations
  for (const { name } of types) {
    lines.push(`declare namespace ${name} {`);
    lines.push(`  export const Schema: SchemaProvider<${name}>;`);
    lines.push(`}`);
    lines.push("");
  }

  return lines.join("\n");
}

/**
 * Get the declaration file path for a source file.
 *
 * @param sourceFile - The path to the source .ts file
 * @returns The path to the .thinkwell.d.ts file
 */
export function getDeclarationPath(sourceFile: string): string {
  const dir = dirname(sourceFile);
  const base = basename(sourceFile).replace(/\.tsx?$/, "");
  return resolve(dir, `${base}.thinkwell.d.ts`);
}

/**
 * Write a declaration file for the given source file and types.
 *
 * @param sourceFile - The path to the source .ts file
 * @param types - The types marked with @JSONSchema in that file
 * @returns The path to the written declaration file, or null if no types
 */
export async function writeDeclarationFile(
  sourceFile: string,
  types: TypeInfo[]
): Promise<string | null> {
  if (types.length === 0) {
    return null;
  }

  const content = generateDeclarationContent(sourceFile, types);
  const declPath = getDeclarationPath(sourceFile);

  await Bun.write(declPath, content);
  return declPath;
}

/**
 * Remove a declaration file if it exists.
 *
 * @param sourceFile - The path to the source .ts file
 * @returns true if a file was removed, false otherwise
 */
export async function removeDeclarationFile(sourceFile: string): Promise<boolean> {
  const declPath = getDeclarationPath(sourceFile);
  try {
    await Bun.file(declPath).exists() && (await Bun.write(declPath, ""));
    const { unlinkSync } = await import("fs");
    unlinkSync(declPath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Options for the declaration generator.
 */
export interface DeclarationGeneratorOptions {
  /**
   * Root directory to watch for TypeScript files.
   * Defaults to the current working directory.
   */
  rootDir?: string;

  /**
   * Glob patterns to include. Defaults to ["**\/*.ts", "**\/*.tsx"].
   */
  include?: string[];

  /**
   * Glob patterns to exclude. Defaults to ["node_modules/**", "**\/*.d.ts"].
   */
  exclude?: string[];

  /**
   * Callback when a declaration file is written.
   */
  onWrite?: (sourceFile: string, declFile: string) => void;

  /**
   * Callback when a declaration file is removed.
   */
  onRemove?: (sourceFile: string, declFile: string) => void;

  /**
   * Callback when an error occurs.
   */
  onError?: (error: Error, sourceFile: string) => void;
}

/**
 * Generate declaration files for all TypeScript files in a directory.
 *
 * @param options - Generator options
 * @returns Array of paths to generated declaration files
 */
export async function generateDeclarations(
  options: DeclarationGeneratorOptions = {}
): Promise<string[]> {
  const {
    rootDir = process.cwd(),
    include = ["**/*.ts", "**/*.tsx"],
    exclude = ["node_modules/**", "**/*.d.ts", "**/*.thinkwell.d.ts"],
    onWrite,
    onError,
  } = options;

  const { findMarkedTypes } = await import("./transform.js");
  const { Glob } = await import("bun");

  const generatedFiles: string[] = [];

  // Pre-compile exclude patterns for better performance
  const excludeGlobs = exclude.map((pattern) => new Glob(pattern));

  for (const pattern of include) {
    const glob = new Glob(pattern);
    for await (const file of glob.scan({ cwd: rootDir, absolute: true })) {
      // Check if file matches any exclude pattern (using pre-compiled globs)
      const relativePath = relative(rootDir, file);
      const shouldExclude = excludeGlobs.some((excludeGlob) =>
        excludeGlob.match(relativePath)
      );

      if (shouldExclude) {
        continue;
      }

      try {
        let source: string;
        try {
          source = await Bun.file(file).text();
        } catch (readError) {
          const err = new FileReadError({ filePath: file, cause: readError });
          onError?.(err, file);
          continue;
        }

        // Fast path: skip files without @JSONSchema
        if (!source.includes("@JSONSchema")) {
          continue;
        }

        const types = findMarkedTypes(file, source);
        if (types.length === 0) {
          continue;
        }

        try {
          const declPath = await writeDeclarationFile(file, types);
          if (declPath) {
            generatedFiles.push(declPath);
            onWrite?.(file, declPath);
          }
        } catch (writeError) {
          const err = new FileWriteError({
            filePath: getDeclarationPath(file),
            cause: writeError,
          });
          onError?.(err, file);
        }
      } catch (error) {
        // Catch any other unexpected errors (e.g., in findMarkedTypes)
        const err = new DeclarationGenerationError({ sourceFile: file, cause: error });
        onError?.(err, file);
      }
    }
  }

  return generatedFiles;
}
