import { describe, test, expect, beforeEach, afterEach } from "bun:test";
import { mkdir, rm, readFile, writeFile } from "fs/promises";
import { join } from "path";
import { tmpdir } from "os";
import {
  generateDeclarationContent,
  getDeclarationPath,
  writeDeclarationFile,
  removeDeclarationFile,
  generateDeclarations,
} from "./declarations.js";
import type { TypeInfo } from "./transform.js";

// Create mock TypeInfo objects for testing
function mockTypeInfo(name: string, endPosition = 100): TypeInfo {
  return {
    name,
    endPosition,
    // The node is not used by the declaration generator
    node: {} as any,
  };
}

describe("generateDeclarationContent", () => {
  test("generates declaration for single type", () => {
    const types = [mockTypeInfo("Greeting")];
    const content = generateDeclarationContent("/path/to/greeting.ts", types);

    expect(content).toContain('import type { SchemaProvider } from "@thinkwell/acp";');
    expect(content).toContain('import type { Greeting } from "./greeting.js";');
    expect(content).toContain("declare namespace Greeting {");
    expect(content).toContain("export const Schema: SchemaProvider<Greeting>;");
  });

  test("generates declaration for multiple types", () => {
    const types = [mockTypeInfo("Greeting"), mockTypeInfo("Farewell")];
    const content = generateDeclarationContent("/path/to/messages.ts", types);

    expect(content).toContain('import type { Greeting, Farewell } from "./messages.js";');
    expect(content).toContain("declare namespace Greeting {");
    expect(content).toContain("declare namespace Farewell {");
  });

  test("returns empty string for no types", () => {
    const content = generateDeclarationContent("/path/to/greeting.ts", []);
    expect(content).toBe("");
  });

  test("handles .tsx files", () => {
    const types = [mockTypeInfo("Props")];
    const content = generateDeclarationContent("/path/to/component.tsx", types);

    expect(content).toContain('import type { Props } from "./component.js";');
  });

  test("includes auto-generated header", () => {
    const types = [mockTypeInfo("Greeting")];
    const content = generateDeclarationContent("/path/to/greeting.ts", types);

    expect(content).toContain("// Auto-generated by @thinkwell/bun-plugin");
    expect(content).toContain("// Do not edit manually");
  });
});

describe("getDeclarationPath", () => {
  test("converts .ts to .thinkwell.d.ts", () => {
    const result = getDeclarationPath("/path/to/greeting.ts");
    expect(result).toBe("/path/to/greeting.thinkwell.d.ts");
  });

  test("converts .tsx to .thinkwell.d.ts", () => {
    const result = getDeclarationPath("/path/to/component.tsx");
    expect(result).toBe("/path/to/component.thinkwell.d.ts");
  });

  test("handles nested paths", () => {
    const result = getDeclarationPath("/project/src/types/greeting.ts");
    expect(result).toBe("/project/src/types/greeting.thinkwell.d.ts");
  });
});

describe("writeDeclarationFile", () => {
  let tempDir: string;

  beforeEach(async () => {
    tempDir = join(tmpdir(), `thinkwell-test-${Date.now()}`);
    await mkdir(tempDir, { recursive: true });
  });

  afterEach(async () => {
    await rm(tempDir, { recursive: true, force: true });
  });

  test("writes declaration file", async () => {
    const sourceFile = join(tempDir, "greeting.ts");
    const types = [mockTypeInfo("Greeting")];

    const declPath = await writeDeclarationFile(sourceFile, types);

    expect(declPath).toBe(join(tempDir, "greeting.thinkwell.d.ts"));
    const content = await readFile(declPath!, "utf-8");
    expect(content).toContain("declare namespace Greeting");
  });

  test("returns null for no types", async () => {
    const sourceFile = join(tempDir, "greeting.ts");
    const declPath = await writeDeclarationFile(sourceFile, []);
    expect(declPath).toBeNull();
  });
});

describe("removeDeclarationFile", () => {
  let tempDir: string;

  beforeEach(async () => {
    tempDir = join(tmpdir(), `thinkwell-test-${Date.now()}`);
    await mkdir(tempDir, { recursive: true });
  });

  afterEach(async () => {
    await rm(tempDir, { recursive: true, force: true });
  });

  test("removes existing declaration file", async () => {
    const declPath = join(tempDir, "greeting.thinkwell.d.ts");
    await writeFile(declPath, "// test content");

    const removed = await removeDeclarationFile(join(tempDir, "greeting.ts"));

    expect(removed).toBe(true);
    const exists = await Bun.file(declPath).exists();
    expect(exists).toBe(false);
  });

  test("returns false for non-existent file", async () => {
    const removed = await removeDeclarationFile(join(tempDir, "nonexistent.ts"));
    expect(removed).toBe(false);
  });
});

describe("generateDeclarations", () => {
  let tempDir: string;

  beforeEach(async () => {
    tempDir = join(tmpdir(), `thinkwell-test-${Date.now()}`);
    await mkdir(tempDir, { recursive: true });
  });

  afterEach(async () => {
    await rm(tempDir, { recursive: true, force: true });
  });

  test("generates declarations for files with @JSONSchema", async () => {
    // Create a test file with @JSONSchema
    const sourceFile = join(tempDir, "greeting.ts");
    await writeFile(
      sourceFile,
      `
      /** @JSONSchema */
      interface Greeting {
        message: string;
      }
    `
    );

    const generated = await generateDeclarations({ rootDir: tempDir });

    expect(generated).toHaveLength(1);
    expect(generated[0]).toContain("greeting.thinkwell.d.ts");

    const content = await readFile(generated[0], "utf-8");
    expect(content).toContain("declare namespace Greeting");
  });

  test("skips files without @JSONSchema", async () => {
    // Create a test file without @JSONSchema
    const sourceFile = join(tempDir, "other.ts");
    await writeFile(
      sourceFile,
      `
      interface Other {
        value: number;
      }
    `
    );

    const generated = await generateDeclarations({ rootDir: tempDir });
    expect(generated).toHaveLength(0);
  });

  test("excludes node_modules", async () => {
    // Create node_modules directory with a file
    const nodeModulesDir = join(tempDir, "node_modules", "some-package");
    await mkdir(nodeModulesDir, { recursive: true });
    await writeFile(
      join(nodeModulesDir, "index.ts"),
      `
      /** @JSONSchema */
      interface SomeType {
        value: string;
      }
    `
    );

    const generated = await generateDeclarations({ rootDir: tempDir });
    expect(generated).toHaveLength(0);
  });

  test("excludes .d.ts files", async () => {
    // Create a .d.ts file
    await writeFile(
      join(tempDir, "types.d.ts"),
      `
      /** @JSONSchema */
      interface TypeDef {
        value: string;
      }
    `
    );

    const generated = await generateDeclarations({ rootDir: tempDir });
    expect(generated).toHaveLength(0);
  });

  test("calls onWrite callback", async () => {
    const sourceFile = join(tempDir, "greeting.ts");
    await writeFile(
      sourceFile,
      `
      /** @JSONSchema */
      interface Greeting {
        message: string;
      }
    `
    );

    const writtenFiles: Array<{ source: string; decl: string }> = [];

    await generateDeclarations({
      rootDir: tempDir,
      onWrite: (source, decl) => writtenFiles.push({ source, decl }),
    });

    expect(writtenFiles).toHaveLength(1);
    expect(writtenFiles[0].source).toContain("greeting.ts");
    expect(writtenFiles[0].decl).toContain("greeting.thinkwell.d.ts");
  });
});
