#!/usr/bin/env node
/**
 * Build tool for generating SchemaProvider modules from TypeScript types.
 *
 * This tool scans TypeScript files for types marked with @JSONSchema JSDoc tag
 * and generates corresponding .schemas.ts files with SchemaProvider exports.
 *
 * Usage:
 *   build-schema-providers [globs...]
 *
 * Examples:
 *   build-schema-providers                    # Process all .ts files in current directory
 *   build-schema-providers src/types.ts       # Process specific file
 *   build-schema-providers "src/**\/*.ts"      # Process files matching glob
 *
 * For each input file foo.ts that contains @JSONSchema-marked types,
 * generates foo.schemas.ts with SchemaProvider<T> exports.
 */

import { writeFileSync, existsSync } from "node:fs";
import { dirname, basename, join, resolve } from "node:path";
import { globSync } from "glob";
import ts from "typescript";
import {
  createGenerator,
  hasJsDocTag,
  symbolAtNode,
  type Config,
} from "ts-json-schema-generator";

const JSONSCHEMA_TAG = "JSONSchema";

interface TypeInfo {
  name: string;
  node: ts.Node;
}

interface FileResult {
  inputPath: string;
  outputPath: string;
  types: string[];
}

/**
 * Find all types marked with @JSONSchema in the given source file.
 */
function findJSONSchemaTypes(
  sourceFile: ts.SourceFile,
  typeChecker: ts.TypeChecker
): TypeInfo[] {
  const results: TypeInfo[] = [];

  ts.forEachChild(sourceFile, function visit(node) {
    if (
      ts.isInterfaceDeclaration(node) ||
      ts.isTypeAliasDeclaration(node) ||
      ts.isEnumDeclaration(node) ||
      ts.isClassDeclaration(node)
    ) {
      if (hasJsDocTag(node, JSONSCHEMA_TAG)) {
        const symbol = symbolAtNode(node);
        if (symbol) {
          const name = typeChecker
            .getFullyQualifiedName(symbol)
            .replace(/^".*"\./, "");
          results.push({ name, node });
        }
      }
    }
    ts.forEachChild(node, visit);
  });

  return results;
}

/**
 * Recursively inline $ref references to make schemas self-contained.
 */
function inlineRefs(
  obj: unknown,
  definitions: Record<string, unknown>
): unknown {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map((item) => inlineRefs(item, definitions));
  }

  const record = obj as Record<string, unknown>;

  // If this object has a $ref, replace it with the referenced definition
  if (typeof record["$ref"] === "string") {
    const ref = record["$ref"];
    const match = ref.match(/^#\/definitions\/(.+)$/);
    if (match && definitions[match[1]]) {
      return inlineRefs(definitions[match[1]], definitions);
    }
  }

  // Otherwise, recursively process all properties
  const result: Record<string, unknown> = {};
  for (const [key, value] of Object.entries(record)) {
    result[key] = inlineRefs(value, definitions);
  }
  return result;
}

/**
 * Generate schema for a single type.
 */
function generateSchema(
  generator: ReturnType<typeof createGenerator>,
  typeName: string
): object {
  const schema = generator.createSchema(typeName);
  const definitions = (schema.definitions || {}) as Record<string, unknown>;

  let result: unknown = definitions[typeName] || schema;
  result = inlineRefs(result, definitions);

  return result as object;
}

/**
 * Generate the .schemas.ts module content.
 */
function generateSchemaModule(
  sourceFileName: string,
  typeNames: string[],
  schemas: Record<string, object>
): string {
  // Get the base name without extension for the import
  const baseName = basename(sourceFileName, ".ts");

  const lines: string[] = [
    "/**",
    " * AUTO-GENERATED FILE - DO NOT EDIT",
    " *",
    " * Generated by: @thinkwell/build-schema-providers",
    ` * Source: ${basename(sourceFileName)}`,
    " *",
    " * This file contains JSON schemas generated from TypeScript types",
    " * marked with @JSONSchema. Re-run the generator if you modify",
    " * the source types.",
    " */",
    "",
    'import type { SchemaProvider, JsonSchema } from "@thinkwell/acp";',
    "import type {",
    ...typeNames.map((t) => `  ${t},`),
    `} from "./${baseName}.js";`,
    "",
    "/**",
    " * Creates a SchemaProvider<T> from a raw JSON schema object.",
    " */",
    "function schemaProvider<T>(schema: Record<string, unknown>): SchemaProvider<T> {",
    "  return {",
    "    toJsonSchema: () => schema as JsonSchema,",
    "  };",
    "}",
    "",
  ];

  // Add each schema
  for (const typeName of typeNames) {
    const schema = schemas[typeName];
    const schemaJson = JSON.stringify(schema, null, 2)
      .split("\n")
      .map((line, i) => (i === 0 ? line : "  " + line))
      .join("\n");

    lines.push(
      "/**",
      ` * SchemaProvider for ${typeName} type.`,
      " * @generated",
      " */",
      `export const ${typeName}Schema: SchemaProvider<${typeName}> = schemaProvider<${typeName}>(${schemaJson});`,
      ""
    );
  }

  return lines.join("\n");
}

/**
 * Find tsconfig.json by walking up from the given directory.
 */
function findTsConfig(startDir: string): string | undefined {
  let dir = startDir;
  while (true) {
    const configPath = join(dir, "tsconfig.json");
    if (existsSync(configPath)) {
      return configPath;
    }
    const parent = dirname(dir);
    if (parent === dir) {
      return undefined;
    }
    dir = parent;
  }
}

/**
 * Process a single TypeScript file.
 */
function processFile(
  inputPath: string,
  program: ts.Program,
  verbose: boolean
): FileResult | null {
  const absolutePath = resolve(inputPath);
  const sourceFile = program.getSourceFile(absolutePath);

  if (!sourceFile) {
    if (verbose) {
      console.log(`  Skipping ${inputPath} (not in program)`);
    }
    return null;
  }

  const typeChecker = program.getTypeChecker();
  const types = findJSONSchemaTypes(sourceFile, typeChecker);

  if (types.length === 0) {
    if (verbose) {
      console.log(`  Skipping ${inputPath} (no @JSONSchema types)`);
    }
    return null;
  }

  const typeNames = types.map((t) => t.name);

  // Create generator for this file
  const configPath = findTsConfig(dirname(absolutePath));
  const config: Config = {
    path: absolutePath,
    ...(configPath && { tsconfig: configPath }),
    skipTypeCheck: true,
    encodeRefs: false,
  };
  const generator = createGenerator(config);

  // Generate schemas
  const schemas: Record<string, object> = {};
  for (const typeName of typeNames) {
    schemas[typeName] = generateSchema(generator, typeName);
  }

  // Generate output: foo.ts -> foo.schemas.ts
  const dir = dirname(absolutePath);
  const base = basename(absolutePath, ".ts");
  const outputPath = join(dir, `${base}.schemas.ts`);
  const content = generateSchemaModule(basename(absolutePath), typeNames, schemas);

  writeFileSync(outputPath, content);

  return {
    inputPath,
    outputPath,
    types: typeNames,
  };
}

/**
 * Main entry point.
 */
function main(): void {
  const args = process.argv.slice(2);

  // Parse options
  let verbose = false;
  const globs: string[] = [];

  for (const arg of args) {
    if (arg === "-v" || arg === "--verbose") {
      verbose = true;
    } else if (arg === "-h" || arg === "--help") {
      console.log(`
build-schema-providers - Generate SchemaProvider modules from TypeScript types

Usage:
  build-schema-providers [options] [globs...]

Options:
  -v, --verbose  Show verbose output
  -h, --help     Show this help message

Arguments:
  globs          File patterns to process (default: "./**/*.ts")

For each input file foo.ts that contains @JSONSchema-marked types,
generates foo.schemas.ts with SchemaProvider<T> exports.

Example:
  build-schema-providers src/types.ts
  build-schema-providers "src/**/*.types.ts"
`);
      process.exit(0);
    } else {
      globs.push(arg);
    }
  }

  // Default glob pattern
  if (globs.length === 0) {
    globs.push("./**/*.ts");
  }

  // Expand globs
  const files: string[] = [];
  for (const pattern of globs) {
    const matches = globSync(pattern, {
      ignore: [
        "**/node_modules/**",
        "**/*.d.ts",
        "**/*.schemas.ts",
        "**/*.test.ts",
        "**/*.spec.ts",
      ],
    });
    files.push(...matches);
  }

  if (files.length === 0) {
    console.log("No TypeScript files found matching the specified patterns.");
    process.exit(0);
  }

  if (verbose) {
    console.log(`Found ${files.length} TypeScript files to scan...\n`);
  }

  // Create a program with all files to enable cross-file type resolution
  const configPath = findTsConfig(process.cwd());
  let compilerOptions: ts.CompilerOptions = {
    noEmit: true,
    skipLibCheck: true,
  };

  if (configPath) {
    const configFile = ts.readConfigFile(configPath, ts.sys.readFile);
    const parsed = ts.parseJsonConfigFileContent(
      configFile.config,
      ts.sys,
      dirname(configPath)
    );
    compilerOptions = { ...parsed.options, ...compilerOptions };
  }

  const absoluteFiles = files.map((f) => resolve(f));
  const program = ts.createProgram(absoluteFiles, compilerOptions);

  // Process each file
  const results: FileResult[] = [];
  for (const file of files) {
    const result = processFile(file, program, verbose);
    if (result) {
      results.push(result);
    }
  }

  // Summary
  if (results.length === 0) {
    console.log("No files with @JSONSchema types found.");
  } else {
    console.log(`Generated ${results.length} schema file(s):\n`);
    for (const result of results) {
      console.log(`  ${result.outputPath}`);
      for (const typeName of result.types) {
        console.log(`    - ${typeName}Schema`);
      }
    }
  }
}

main();
