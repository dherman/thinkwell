/**
 * Generates the augmentation `.d.ts` content from discovered
 * @JSONSchema-marked types. The plugin writes this to disk at
 * `.thinkwell/augmentations.d.ts` in the project root.
 */

import type { MarkedType } from "./scanner";
import path from "node:path";

/**
 * Generate a namespace merge declaration for a single marked type.
 *
 * Produces a declaration like:
 * ```
 * declare namespace Greeting {
 *   export const Schema: import("thinkwell").SchemaProvider<import("../src/types").Greeting>;
 * }
 * ```
 *
 * Uses `import("thinkwell").SchemaProvider` rather than a locally-declared
 * interface so that TypeScript sees the *same* generic type that `think()`
 * expects. A local `SchemaProvider<T>` looks structurally identical but
 * `T` is a phantom parameter (unused in any property types), so TS can't
 * infer it across two different generic interfaces and falls back to
 * `unknown`.
 *
 * The type parameter also uses `import()` to reference the type from its
 * source module. A bare `<Greeting>` would resolve to the namespace being
 * declared (a global ambient symbol), not the interface exported from the
 * source module. This causes properties that reference other @JSONSchema
 * types (e.g., `functions: FunctionInfo[]`) to resolve to `any`.
 *
 * The `import()` type references keep the file as an ambient script
 * (no top-level import/export) so namespace declarations merge globally.
 */
function generateNamespaceDeclaration(
  type: MarkedType,
  sourceModulePath: string,
): string {
  return [
    `declare namespace ${type.name} {`,
    `  export const Schema: import("thinkwell").SchemaProvider<import("${sourceModulePath}").${type.name}>;`,
    `}`,
  ].join("\n");
}

/**
 * Compute the relative module specifier from the augmentations file to a
 * source file, suitable for use in `import("...")` type references.
 *
 * Strips the `.ts` / `.tsx` extension and ensures a leading `./` or `../`.
 */
function relativeModulePath(
  augmentationsFilePath: string,
  sourceFilePath: string,
): string {
  const augDir = path.dirname(augmentationsFilePath);
  let rel = path.relative(augDir, sourceFilePath);

  // Replace .ts/.tsx with .js/.jsx for module specifiers.
  // This is required for Node16 moduleResolution (which requires
  // explicit extensions) and also works fine under Node10.
  rel = rel.replace(/\.tsx$/, ".jsx").replace(/\.ts$/, ".js");

  // Ensure a leading ./ for same-directory or child paths
  if (!rel.startsWith(".")) {
    rel = "./" + rel;
  }

  // Normalize to forward slashes (for Windows compatibility)
  return rel.split(path.sep).join("/");
}

/**
 * Generate the full virtual declaration file content from all marked types
 * across the project.
 *
 * @param typesByFile - Map from file path to the marked types found in that file.
 * @param augmentationsFilePath - Absolute path to the augmentations .d.ts file,
 *   used to compute relative import paths for type references.
 * @returns The complete `.d.ts` content for the virtual augmentations file.
 */
export function generateVirtualDeclarations(
  typesByFile: Map<string, MarkedType[]>,
  augmentationsFilePath: string,
): string {
  // Collect all types first — return empty string if there are none.
  // Writing an empty or header-only .d.ts causes TS 5.9's setDocument
  // to crash during updateGraphWorker.
  const allTypes: { fileName: string; type: MarkedType }[] = [];
  for (const [fileName, types] of typesByFile) {
    for (const type of types) {
      allTypes.push({ fileName, type });
    }
  }

  if (allTypes.length === 0) return "";

  const declarations: string[] = [
    "// Auto-generated by @thinkwell/vscode-ts-plugin — do not edit.",
    "",
  ];

  let currentFile = "";
  for (const { fileName, type } of allTypes) {
    if (fileName !== currentFile) {
      declarations.push(`// From ${fileName}`);
      currentFile = fileName;
    }
    const modulePath = relativeModulePath(augmentationsFilePath, fileName);
    declarations.push(generateNamespaceDeclaration(type, modulePath));
    declarations.push("");
  }

  return declarations.join("\n");
}
