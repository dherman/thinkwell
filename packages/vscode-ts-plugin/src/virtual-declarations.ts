/**
 * Generates the augmentation `.d.ts` content from discovered
 * @JSONSchema-marked types. The plugin writes this to disk at
 * `.thinkwell/augmentations.d.ts` in the project root.
 */

import type { MarkedType } from "./scanner";

/**
 * Generate a namespace merge declaration for a single marked type.
 *
 * Produces a declaration like:
 * ```
 * declare namespace Greeting {
 *   export const Schema: SchemaProvider<Greeting>;
 * }
 * ```
 *
 * The `SchemaProvider` interface is declared locally in the generated file
 * so it has zero external module dependencies (important for standalone
 * scripts that don't have `node_modules`).
 *
 * The virtual file must be an ambient script (no top-level `export`), so
 * namespace declarations never use an `export` prefix. TypeScript merges
 * ambient namespaces with imported types regardless of the type's export status.
 */
function generateNamespaceDeclaration(type: MarkedType): string {
  return [
    `declare namespace ${type.name} {`,
    `  export const Schema: SchemaProvider<${type.name}>;`,
    `}`,
  ].join("\n");
}

/**
 * Generate the full virtual declaration file content from all marked types
 * across the project.
 *
 * @param typesByFile - Map from file path to the marked types found in that file.
 * @returns The complete `.d.ts` content for the virtual augmentations file.
 */
export function generateVirtualDeclarations(
  typesByFile: Map<string, MarkedType[]>,
): string {
  // Collect all types first — return empty string if there are none.
  // Writing an empty or header-only .d.ts causes TS 5.9's setDocument
  // to crash during updateGraphWorker.
  const allTypes: { fileName: string; type: MarkedType }[] = [];
  for (const [fileName, types] of typesByFile) {
    for (const type of types) {
      allTypes.push({ fileName, type });
    }
  }

  if (allTypes.length === 0) return "";

  const declarations: string[] = [
    "// Auto-generated by @thinkwell/vscode-ts-plugin — do not edit.",
    "",
    "/** A JSON Schema provider for type T, injected by the thinkwell runtime. */",
    "interface SchemaProvider<T> {",
    "  toJsonSchema(): Record<string, unknown>;",
    "}",
    "",
  ];

  let currentFile = "";
  for (const { fileName, type } of allTypes) {
    if (fileName !== currentFile) {
      declarations.push(`// From ${fileName}`);
      currentFile = fileName;
    }
    declarations.push(generateNamespaceDeclaration(type));
    declarations.push("");
  }

  return declarations.join("\n");
}
