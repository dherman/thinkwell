# RFD: Thinkwell CLI and Bun Plugin for Automatic Schema Generation

## Summary

This document proposes a `thinkwell` CLI and accompanying Bun plugin that automatically generates JSON Schema definitions from TypeScript types marked with `@JSONSchema`, eliminating the need for separate schema files or explicit build steps. The CLI wraps Bun with the plugin pre-configured, enabling a zero-configuration scripting experience.

## Motivation

### Current State

Today, using typed schemas with thinkwell requires a multi-step workflow:

```typescript
// greeting.ts - hand-written
/** @JSONSchema */
export interface Greeting {
  message: string;
}

namespace Greeting {
  export const Schema = GreetingSchema;  // Import from generated file
}

// greeting.schemas.ts - generated by build-schema-providers
export const GreetingSchema: SchemaProvider<Greeting> = { ... };
```

Users must:
1. Run `build-schema-providers` as a separate build step
2. Import the generated schema from a companion file
3. Wire up the namespace manually

This friction is acceptable for larger projects but creates unnecessary ceremony for quick scripts and prototypes.

### Vision: Scripting with Thinkwell

With Bun gaining traction as an AI runtime (recently acquired by Anthropic), there's an opportunity to make thinkwell scripts as simple as:

```typescript
#!/usr/bin/env thinkwell
// hello.ts

import { Agent } from "thinkwell:agent";
import { CLAUDE_CODE } from "thinkwell:connectors";

/** @JSONSchema */
interface Greeting {
  /** The greeting message */
  message: string;
}

const agent = await Agent.connect(CLAUDE_CODE);
const greeting: Greeting = await agent
  .think(Greeting.Schema)  // Schema is automatically available!
  .text("Say hello")
  .run();

console.log(greeting.message);
```

Run with just:
```bash
thinkwell hello.ts
```

Or make it executable:
```bash
chmod +x hello.ts
./hello.ts
```

No build step. No configuration files. No generated files. No `package.json` required. The schema materializes automatically, and thinkwell modules are built-in.

### The `thinkwell:*` URI Scheme

Thinkwell scripts use a custom URI scheme for imports, similar to Node.js's `node:*` and Bun's `bun:*` built-in modules:

```typescript
import { Agent } from "thinkwell:agent";
import { CLAUDE_CODE } from "thinkwell:connectors";
import type { SchemaProvider } from "thinkwell:acp";
```

This design provides several benefits:

1. **Zero configuration**: Users don't need a `package.json` or `node_modules` - modules are built into the runtime
2. **Explicit built-in signal**: The `thinkwell:` prefix clearly indicates these are provided by the runtime, not user dependencies
3. **Familiar pattern**: Follows the established convention of `node:fs`, `bun:test`, etc.
4. **Version consistency**: All thinkwell modules are versioned together with the CLI

The plugin registers an `onResolve` hook that intercepts `thinkwell:*` imports and resolves them to bundled modules shipped with the CLI.

## Design Goals

1. **Zero configuration**: `thinkwell script.ts` just works
2. **Transparent integration**: Types remain hand-written; schemas appear magically
3. **Type safety**: Full TypeScript type checking preserved
4. **Development velocity**: Changes to types immediately reflected without rebuild
5. **Future-proof**: Works with TypeScript 7/tsgo (uses TS Compiler API separately)
6. **Extensible CLI**: Foundation for future commands (`thinkwell build`, `thinkwell init`)

## Proposal

### The `thinkwell` CLI

The primary user interface is the `thinkwell` command, a thin wrapper around Bun that automatically loads the schema generation plugin:

```bash
thinkwell script.ts           # Run a script
thinkwell run script.ts       # Explicit run subcommand (equivalent)
./script.ts                   # Via shebang: #!/usr/bin/env thinkwell
```

#### CLI Implementation

The CLI is a Bun script compiled to a standalone binary using `bun build --compile`:

```typescript
// packages/cli/src/index.ts
import { spawn } from "bun";
import { resolve, dirname } from "path";

const pluginPath = resolve(dirname(Bun.main), "./plugin.js");
const args = Bun.argv.slice(2);

// Handle subcommands
const command = args[0];
if (command === "run") {
  args.shift();  // Remove "run", pass rest to bun
}

// Delegate to bun with our plugin preloaded
const proc = spawn(["bun", "--preload", pluginPath, ...args], {
  stdio: ["inherit", "inherit", "inherit"],
  env: process.env,
});

await proc.exited;
process.exit(proc.exitCode ?? 0);
```

#### Build Process

```bash
# Build standalone binary
bun build --compile --outfile thinkwell ./src/index.ts

# The result is a single executable (~50MB with Bun runtime embedded)
# Or smaller if we require Bun to be installed separately
```

#### Distribution

Two distribution options:

1. **npm package** (requires Bun installed):
   ```bash
   npm install -g thinkwell
   # or
   bun install -g thinkwell
   ```
   The package includes a Node.js launcher that delegates to Bun.

2. **Standalone binary** (self-contained):
   ```bash
   curl -fsSL https://thinkwell.dev/install.sh | bash
   ```
   Single binary with Bun runtime embedded. No dependencies.

**Recommendation**: Start with npm distribution (Option 1). Users interested in thinkwell likely already have Bun. Add standalone binaries later for CI/CD environments.

### Module Resolution

The plugin uses Bun's `onResolve` hook to intercept `thinkwell:*` imports and resolve them to bundled modules:

```typescript
// In the plugin setup
build.onResolve({ filter: /^thinkwell:/ }, (args) => {
  // thinkwell:agent -> bundled agent module
  // thinkwell:acp -> bundled acp module
  // thinkwell:connectors -> bundled connectors module
  const moduleName = args.path.replace("thinkwell:", "");
  return {
    path: resolve(THINKWELL_MODULES_DIR, `${moduleName}.js`),
    namespace: "file",
  };
});
```

Available built-in modules:

| Import | Description |
|--------|-------------|
| `thinkwell:agent` | Core `Agent` class for interacting with AI models |
| `thinkwell:acp` | ACP types including `SchemaProvider`, `JsonSchema` |
| `thinkwell:connectors` | Pre-configured connectors like `CLAUDE_CODE` |
| `thinkwell:protocol` | Low-level protocol types |

### Plugin Architecture

The plugin uses Bun's `onLoad` hook to intercept TypeScript files and inject schema definitions:

```
                                    ┌─────────────────┐
                                    │  TypeScript     │
                                    │  Compiler API   │
                                    │  (type info)    │
                                    └────────┬────────┘
                                             │
┌──────────┐    ┌──────────────┐    ┌────────▼────────┐    ┌──────────┐
│  .ts     │───▶│  Bun onLoad  │───▶│  Schema         │───▶│ Modified │
│  source  │    │  intercept   │    │  Generator      │    │ .ts      │
└──────────┘    └──────────────┘    └────────┬────────┘    └──────────┘
                                             │
                                    ┌────────▼────────┐
                                    │ ts-json-schema- │
                                    │ generator       │
                                    └─────────────────┘
```

### Plugin Implementation

```typescript
// @thinkwell/bun-plugin/src/index.ts
import { plugin } from "bun";
import ts from "typescript";
import { createGenerator, type Config } from "ts-json-schema-generator";

const JSONSCHEMA_TAG = "JSONSchema";

export default plugin({
  name: "thinkwell-schema",

  setup(build) {
    build.onLoad({ filter: /\.tsx?$/ }, async ({ path }) => {
      const source = await Bun.file(path).text();

      // Fast path: skip files without @JSONSchema
      if (!source.includes(`@${JSONSCHEMA_TAG}`)) {
        return undefined;  // Let Bun handle normally
      }

      // Parse with TypeScript to find marked types
      const sourceFile = ts.createSourceFile(
        path,
        source,
        ts.ScriptTarget.Latest,
        true
      );

      const markedTypes = findMarkedTypes(sourceFile);
      if (markedTypes.length === 0) {
        return undefined;
      }

      // Generate schemas using ts-json-schema-generator
      const schemas = generateSchemas(path, markedTypes);

      // Inject namespace declarations with schemas
      const injectedCode = generateInjections(markedTypes, schemas);
      const modifiedSource = source + "\n" + injectedCode;

      return {
        contents: modifiedSource,
        loader: path.endsWith(".tsx") ? "tsx" : "ts"
      };
    });
  },
});

function findMarkedTypes(sourceFile: ts.SourceFile): TypeInfo[] {
  const results: TypeInfo[] = [];

  ts.forEachChild(sourceFile, function visit(node) {
    if (ts.isInterfaceDeclaration(node) || ts.isTypeAliasDeclaration(node)) {
      if (hasJsDocTag(node, JSONSCHEMA_TAG)) {
        results.push({
          name: node.name.text,
          node,
        });
      }
    }
    ts.forEachChild(node, visit);
  });

  return results;
}

function generateInjections(
  types: TypeInfo[],
  schemas: Map<string, object>
): string {
  const lines: string[] = [
    "",
    "// Auto-generated by @thinkwell/bun-plugin",
    'import type { SchemaProvider, JsonSchema } from "thinkwell:acp";',
    "",
  ];

  for (const { name } of types) {
    const schema = schemas.get(name);
    const schemaJson = JSON.stringify(schema, null, 2);

    lines.push(
      `namespace ${name} {`,
      `  export const Schema: SchemaProvider<${name}> = {`,
      `    toJsonSchema: () => (${schemaJson}) as JsonSchema,`,
      `  };`,
      `}`,
      ""
    );
  }

  return lines.join("\n");
}
```

### Usage

#### Primary: The `thinkwell` CLI

```bash
# Run a script
thinkwell script.ts

# Or with shebang
#!/usr/bin/env thinkwell
```

This is the recommended approach for most users.

#### Alternative: Direct Bun Integration

For users who want to integrate the plugin into an existing Bun workflow:

**bunfig.toml:**
```toml
preload = ["@thinkwell/bun-plugin"]
```

**CLI flag:**
```bash
bun --preload @thinkwell/bun-plugin script.ts
```

**Programmatic (for custom build pipelines):**
```typescript
import thinkwellPlugin from "@thinkwell/bun-plugin";

await Bun.build({
  entrypoints: ["./src/index.ts"],
  outdir: "./dist",
  plugins: [thinkwellPlugin],
});
```

### Example Transformation

**Input** (`greeting.ts`):
```typescript
import { Agent } from "thinkwell:agent";
import { CLAUDE_CODE } from "thinkwell:connectors";

/**
 * A friendly greeting.
 * @JSONSchema
 */
export interface Greeting {
  /** The greeting message */
  message: string;
}

const agent = await Agent.connect(CLAUDE_CODE);
const result = await agent.think(Greeting.Schema).text("Hi").run();
```

**After Plugin** (what Bun sees):
```typescript
import { Agent } from "thinkwell:agent";
import { CLAUDE_CODE } from "thinkwell:connectors";

/**
 * A friendly greeting.
 * @JSONSchema
 */
export interface Greeting {
  /** The greeting message */
  message: string;
}

const agent = await Agent.connect(CLAUDE_CODE);
const result = await agent.think(Greeting.Schema).text("Hi").run();

// Auto-generated by @thinkwell/bun-plugin
import type { SchemaProvider, JsonSchema } from "thinkwell:acp";

namespace Greeting {
  export const Schema: SchemaProvider<Greeting> = {
    toJsonSchema: () => ({
      "type": "object",
      "properties": {
        "message": {
          "type": "string",
          "description": "The greeting message"
        }
      },
      "required": ["message"],
      "additionalProperties": false,
      "description": "A friendly greeting."
    }) as JsonSchema,
  };
}
```

The `thinkwell:agent` and `thinkwell:connectors` imports are resolved by the plugin's `onResolve` hook to bundled modules. The injected `thinkwell:acp` import for `SchemaProvider` is also resolved the same way.

### TypeScript Language Service Integration

For IDE support (autocomplete, type checking), we need TypeScript to understand that `Greeting.Schema` exists. Two approaches:

#### Approach A: Ambient Declaration File

Generate a `.d.ts` file that declares the namespace:

```typescript
// greeting.thinkwell.d.ts (auto-generated, gitignored)
import type { SchemaProvider } from "thinkwell:acp";
import type { Greeting } from "./greeting.js";

declare namespace Greeting {
  export const Schema: SchemaProvider<Greeting>;
}
```

The plugin can generate these on first load and update them when types change.

#### Approach B: TypeScript Plugin

A TypeScript language service plugin that provides virtual declarations:

```json
// tsconfig.json
{
  "compilerOptions": {
    "plugins": [{ "name": "@thinkwell/ts-plugin" }]
  }
}
```

This approach provides a better IDE experience but requires additional tooling.

**Recommendation**: Start with Approach A (ambient declarations). It's simpler and works immediately. Add a TS plugin later if needed.

## Performance Considerations

### Startup Latency

The plugin adds latency to first file load:
1. **Fast path check**: ~0.1ms (string search for `@JSONSchema`)
2. **TypeScript parse**: ~5-20ms per file
3. **Schema generation**: ~10-50ms per type

For a typical script with 1-3 types, expect ~50-100ms additional startup time.

### Caching Strategy

To minimize repeat work:

```typescript
const schemaCache = new Map<string, { mtime: number; schemas: Map<string, object> }>();

build.onLoad({ filter: /\.tsx?$/ }, async ({ path }) => {
  const stat = await Bun.file(path).stat();
  const cached = schemaCache.get(path);

  if (cached && cached.mtime === stat.mtime) {
    // Use cached schemas
    return generateOutput(cached.schemas);
  }

  // Generate fresh and cache
  const schemas = generateSchemas(path);
  schemaCache.set(path, { mtime: stat.mtime, schemas });
  return generateOutput(schemas);
});
```

### Parallel Type Checking

For projects with many `@JSONSchema` types, we can use Bun's worker threads:

```typescript
// Future optimization
const worker = new Worker("./schema-worker.ts");
const schemas = await worker.generateSchemas(path, typeNames);
```

## Limitations

### 1. Bun-Only

This approach only works with Bun. Users of Node.js, Deno, or other runtimes must use the existing `build-schema-providers` approach.

**Mitigation**: The build tool remains available. This plugin is an additional convenience, not a replacement.

### 2. No Cross-File Type Resolution (Initial Version)

The initial implementation handles types defined in the same file. Types imported from other files require the TypeScript program API:

```typescript
// This works
/** @JSONSchema */
interface Greeting { message: string; }

// This requires more work
import { BaseType } from "./types.js";
/** @JSONSchema */
interface Greeting extends BaseType { message: string; }
```

**Mitigation**: Use `ts.createProgram()` with all project files for full type resolution. This adds startup cost but enables full type support.

### 3. Declaration Merging Complexity

TypeScript's namespace declaration merging has edge cases:

```typescript
// User's code
interface Greeting { message: string; }
namespace Greeting {
  export function create(): Greeting { return { message: "hi" }; }
}

// Plugin adds
namespace Greeting {
  export const Schema: SchemaProvider<Greeting> = { ... };
}
```

This should work (namespaces merge), but needs testing with various patterns.

### 4. Source Maps

Injecting code at the end of the file may affect source map accuracy for errors in injected code. This is acceptable since:
- Errors in generated code are rare
- Stack traces for user code remain accurate

## Alternatives Considered

### 1. TypeScript Transformer Plugin (ts-patch)

Use ts-patch to hook into the TypeScript compiler directly.

**Pros**: Works with tsc, full type information
**Cons**:
- Won't work with TypeScript 7/tsgo (no transformer API)
- Requires patching TypeScript installation
- More complex setup

**Decision**: Rejected. TypeScript 7 is coming in early 2026, and Microsoft has indicated [transformer plugins won't be supported](https://github.com/microsoft/typescript-go/issues/516).

### 2. Bun Macros

Use Bun's macro system for compile-time schema generation:

```typescript
import { schemaFor } from "@thinkwell/macros" with { type: "macro" };

interface Greeting { message: string; }
const GreetingSchema = schemaFor<Greeting>();  // Evaluated at bundle time
```

**Pros**: Native Bun feature, no plugin needed
**Cons**:
- Macros can't access generic type parameters at compile time
- Would require passing type name as string: `schemaFor("Greeting")`
- Less ergonomic than namespace pattern

**Decision**: Rejected. The namespace pattern (`Greeting.Schema`) is more idiomatic.

### 3. Keep Build Step Only

Continue requiring `build-schema-providers` for all use cases.

**Pros**: Works everywhere, no runtime overhead
**Cons**: Friction for scripting use case, ceremony for small projects

**Decision**: Keep build tool for production, add plugin for development/scripting.

## Implementation Plan

See [plan.md](../plan.md) for the detailed implementation checklist.

## Package Structure

```
packages/
  bun-plugin/              # @thinkwell/bun-plugin
    src/
      index.ts             # Plugin entry point
      transform.ts         # Source transformation logic
      schema-cache.ts      # Caching layer
      declarations.ts      # .d.ts file generation
    package.json
    README.md

  cli/                     # thinkwell (npm: thinkwell)
    src/
      index.ts             # CLI entry point
      commands/
        run.ts             # Default command: run a script
    bin/
      thinkwell            # npm bin entry (Node.js launcher)
    package.json           # depends on @thinkwell/bun-plugin
    README.md
```

### CLI Package Details

```json
// packages/cli/package.json
{
  "name": "thinkwell",
  "version": "0.1.0",
  "bin": {
    "thinkwell": "./bin/thinkwell"
  },
  "dependencies": {
    "@thinkwell/bun-plugin": "workspace:*"
  }
}
```

The `bin/thinkwell` launcher detects the environment and delegates appropriately:

```bash
#!/usr/bin/env node
// Detect if bun is available, delegate with plugin preload
const { execSync, spawn } = require("child_process");
const path = require("path");

try {
  execSync("bun --version", { stdio: "ignore" });
} catch {
  console.error("Error: Bun is required. Install it from https://bun.sh");
  process.exit(1);
}

const pluginPath = path.resolve(__dirname, "../node_modules/@thinkwell/bun-plugin");
const args = process.argv.slice(2);

spawn("bun", ["--preload", pluginPath, ...args], { stdio: "inherit" })
  .on("exit", (code) => process.exit(code ?? 0));
```

## Security Considerations

- **File access**: Plugin only reads files Bun would already load
- **Code injection**: Injected code is deterministic from type definitions
- **No network**: All processing is local

## Testing Strategy

1. **Unit tests**: Schema generation, namespace injection
2. **Integration tests**: Full plugin with Bun.build
3. **Snapshot tests**: Verify output for various type patterns
4. **Comparison tests**: Ensure parity with build-schema-providers output

## Open Questions

1. **Should the plugin work in production builds?**

   The plugin adds latency. For production, users might prefer pre-generated schemas. Options:
   - Always use plugin (simplicity)
   - Environment-based: plugin in dev, build tool in prod
   - Add `thinkwell build` command that pre-generates schemas

2. **How should we handle schema generation errors?**

   If a type can't be converted to JSON Schema:
   - Throw at load time (fail fast)
   - Log warning and skip (permissive)
   - Generate a permissive schema with `additionalProperties: true`

3. **Should we support other runtimes via similar plugins?**

   Deno has a similar plugin system. Node.js has loaders. Worth exploring after Bun version is stable.

4. **Future CLI commands?**

   The `thinkwell` CLI could grow to include:
   - `thinkwell build` - Bundle for production with pre-generated schemas
   - `thinkwell init` - Scaffold a new thinkwell project
   - `thinkwell check` - Validate types and schemas without running

## References

- [Bun Plugin API](https://bun.sh/docs/bundler/plugins)
- [Bun Runtime Plugins](https://bun.sh/docs/runtime/plugins)
- [Bun Build --compile](https://bun.sh/docs/bundler/executables)
- [ts-json-schema-generator](https://github.com/vega/ts-json-schema-generator)
- [TypeScript Compiler API](https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API)
- [TypeScript-Go Issue #516: Transformer Plugin Support](https://github.com/microsoft/typescript-go/issues/516)
- [RFD: Schema Provider Interface](./schema-providers.md)
