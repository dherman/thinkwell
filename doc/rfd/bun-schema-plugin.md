# RFD: Thinkwell CLI and Bun Plugin for Automatic Schema Generation

## Summary

This document proposes a `thinkwell` CLI and accompanying Bun plugin that automatically generates JSON Schema definitions from TypeScript types marked with `@JSONSchema`, eliminating the need for separate schema files or explicit build steps. The CLI wraps Bun with the plugin pre-configured, enabling a zero-configuration scripting experience.

## Motivation

### Current State

Today, using typed schemas with thinkwell requires a multi-step workflow:

```typescript
// greeting.ts - hand-written
/** @JSONSchema */
export interface Greeting {
  message: string;
}

namespace Greeting {
  export const Schema = GreetingSchema;  // Import from generated file
}

// greeting.schemas.ts - generated by build-schema-providers
export const GreetingSchema: SchemaProvider<Greeting> = { ... };
```

Users must:
1. Run `build-schema-providers` as a separate build step
2. Import the generated schema from a companion file
3. Wire up the namespace manually

This friction is acceptable for larger projects but creates unnecessary ceremony for quick scripts and prototypes.

### Vision: Scripting with Thinkwell

With Bun gaining traction as an AI runtime (recently acquired by Anthropic), there's an opportunity to make thinkwell scripts as simple as:

```typescript
#!/usr/bin/env thinkwell
// hello.ts

import { Agent } from "thinkwell:agent";
import { CLAUDE_CODE } from "thinkwell:connectors";

/** @JSONSchema */
interface Greeting {
  /** The greeting message */
  message: string;
}

const agent = await Agent.connect(CLAUDE_CODE);
const greeting: Greeting = await agent
  .think(Greeting.Schema)  // Schema is automatically available!
  .text("Say hello")
  .run();

console.log(greeting.message);
```

Run with just:
```bash
thinkwell hello.ts
```

Or make it executable:
```bash
chmod +x hello.ts
./hello.ts
```

No build step. No configuration files. No generated files. No `package.json` required. The schema materializes automatically, and thinkwell modules are built-in.

### The `thinkwell:*` URI Scheme

Thinkwell scripts use a custom URI scheme for imports, similar to Node.js's `node:*` and Bun's `bun:*` built-in modules:

```typescript
import { Agent } from "thinkwell:agent";
import { CLAUDE_CODE } from "thinkwell:connectors";
import type { SchemaProvider } from "thinkwell:acp";
```

This design provides several benefits:

1. **Zero configuration**: Users don't need a `package.json` or `node_modules` - modules are built into the runtime
2. **Explicit built-in signal**: The `thinkwell:` prefix clearly indicates these are provided by the runtime, not user dependencies
3. **Familiar pattern**: Follows the established convention of `node:fs`, `bun:test`, etc.
4. **Version consistency**: All thinkwell modules are versioned together with the CLI

The plugin registers an `onResolve` hook that intercepts `thinkwell:*` imports and resolves them to bundled modules shipped with the CLI.

## Design Goals

1. **Zero configuration**: `thinkwell script.ts` just works
2. **Transparent integration**: Types remain hand-written; schemas appear magically
3. **Type safety**: Full TypeScript type checking preserved
4. **Development velocity**: Changes to types immediately reflected without rebuild
5. **Future-proof**: Works with TypeScript 7/tsgo (uses TS Compiler API separately)
6. **Extensible CLI**: Foundation for future commands (`thinkwell build`, `thinkwell init`)

## Proposal

### The `thinkwell` CLI

The primary user interface is the `thinkwell` command, a thin wrapper around Bun that automatically loads the schema generation plugin:

```bash
thinkwell script.ts           # Run a script
thinkwell run script.ts       # Explicit run subcommand (equivalent)
./script.ts                   # Via shebang: #!/usr/bin/env thinkwell
```

#### CLI Implementation

The CLI is a Bun script compiled to a standalone binary using `bun build --compile`:

```typescript
// packages/cli/src/index.ts
import { spawn } from "bun";
import { resolve, dirname } from "path";

const pluginPath = resolve(dirname(Bun.main), "./plugin.js");
const args = Bun.argv.slice(2);

// Handle subcommands
const command = args[0];
if (command === "run") {
  args.shift();  // Remove "run", pass rest to bun
}

// Delegate to bun with our plugin preloaded
const proc = spawn(["bun", "--preload", pluginPath, ...args], {
  stdio: ["inherit", "inherit", "inherit"],
  env: process.env,
});

await proc.exited;
process.exit(proc.exitCode ?? 0);
```

#### Build Process

```bash
# Build standalone binary
bun build --compile --outfile thinkwell ./src/index.ts

# The result is a single executable (~50MB with Bun runtime embedded)
# Or smaller if we require Bun to be installed separately
```

#### Distribution

Two distribution options:

1. **npm package** (requires Bun installed):
   ```bash
   npm install -g thinkwell
   # or
   bun install -g thinkwell
   ```
   The package includes a Node.js launcher that delegates to Bun.

2. **Standalone binary** (self-contained):
   ```bash
   curl -fsSL https://thinkwell.dev/install.sh | bash
   ```
   Single binary with Bun runtime embedded. No dependencies.

**Recommendation**: Start with npm distribution (Option 1). Users interested in thinkwell likely already have Bun. Add standalone binaries later for CI/CD environments.

### Module Resolution

The plugin uses Bun's `onResolve` hook to intercept `thinkwell:*` imports and resolve them to bundled modules:

```typescript
// In the plugin setup
build.onResolve({ filter: /^thinkwell:/ }, (args) => {
  // thinkwell:agent -> bundled agent module
  // thinkwell:acp -> bundled acp module
  // thinkwell:connectors -> bundled connectors module
  const moduleName = args.path.replace("thinkwell:", "");
  return {
    path: resolve(THINKWELL_MODULES_DIR, `${moduleName}.js`),
    namespace: "file",
  };
});
```

Available built-in modules:

| Import | Description |
|--------|-------------|
| `thinkwell:agent` | Core `Agent` class for interacting with AI models |
| `thinkwell:acp` | ACP types including `SchemaProvider`, `JsonSchema` |
| `thinkwell:connectors` | Pre-configured connectors like `CLAUDE_CODE` |
| `thinkwell:protocol` | Low-level protocol types |

### Plugin Architecture

The plugin uses Bun's `onLoad` hook to intercept TypeScript files and inject schema definitions:

```
                                    ┌─────────────────┐
                                    │  TypeScript     │
                                    │  Compiler API   │
                                    │  (type info)    │
                                    └────────┬────────┘
                                             │
┌──────────┐    ┌──────────────┐    ┌────────▼────────┐    ┌──────────┐
│  .ts     │───▶│  Bun onLoad  │───▶│  Schema         │───▶│ Modified │
│  source  │    │  intercept   │    │  Generator      │    │ .ts      │
└──────────┘    └──────────────┘    └────────┬────────┘    └──────────┘
                                             │
                                    ┌────────▼────────┐
                                    │ ts-json-schema- │
                                    │ generator       │
                                    └─────────────────┘
```

### Plugin Implementation

```typescript
// @thinkwell/bun-plugin/src/index.ts
import { plugin } from "bun";
import ts from "typescript";
import { createGenerator, type Config } from "ts-json-schema-generator";

const JSONSCHEMA_TAG = "JSONSchema";

export default plugin({
  name: "thinkwell-schema",

  setup(build) {
    build.onLoad({ filter: /\.tsx?$/ }, async ({ path }) => {
      const source = await Bun.file(path).text();

      // Fast path: skip files without @JSONSchema
      if (!source.includes(`@${JSONSCHEMA_TAG}`)) {
        return undefined;  // Let Bun handle normally
      }

      // Parse with TypeScript to find marked types
      const sourceFile = ts.createSourceFile(
        path,
        source,
        ts.ScriptTarget.Latest,
        true
      );

      const markedTypes = findMarkedTypes(sourceFile);
      if (markedTypes.length === 0) {
        return undefined;
      }

      // Generate schemas using ts-json-schema-generator
      const schemas = generateSchemas(path, markedTypes);

      // Inject namespace declarations with schemas
      const injectedCode = generateInjections(markedTypes, schemas);
      const modifiedSource = source + "\n" + injectedCode;

      return {
        contents: modifiedSource,
        loader: path.endsWith(".tsx") ? "tsx" : "ts"
      };
    });
  },
});

function findMarkedTypes(sourceFile: ts.SourceFile): TypeInfo[] {
  const results: TypeInfo[] = [];

  ts.forEachChild(sourceFile, function visit(node) {
    if (ts.isInterfaceDeclaration(node) || ts.isTypeAliasDeclaration(node)) {
      if (hasJsDocTag(node, JSONSCHEMA_TAG)) {
        results.push({
          name: node.name.text,
          node,
        });
      }
    }
    ts.forEachChild(node, visit);
  });

  return results;
}

function generateInjections(
  types: TypeInfo[],
  schemas: Map<string, object>
): string {
  const lines: string[] = [
    "",
    "// Auto-generated by @thinkwell/bun-plugin",
    'import type { SchemaProvider, JsonSchema } from "thinkwell:acp";',
    "",
  ];

  for (const { name } of types) {
    const schema = schemas.get(name);
    const schemaJson = JSON.stringify(schema, null, 2);

    lines.push(
      `namespace ${name} {`,
      `  export const Schema: SchemaProvider<${name}> = {`,
      `    toJsonSchema: () => (${schemaJson}) as JsonSchema,`,
      `  };`,
      `}`,
      ""
    );
  }

  return lines.join("\n");
}
```

### Usage

#### Primary: The `thinkwell` CLI

```bash
# Run a script
thinkwell script.ts

# Or with shebang
#!/usr/bin/env thinkwell
```

This is the recommended approach for most users.

#### Alternative: Direct Bun Integration

For users who want to integrate the plugin into an existing Bun workflow:

**bunfig.toml:**
```toml
preload = ["@thinkwell/bun-plugin"]
```

**CLI flag:**
```bash
bun --preload @thinkwell/bun-plugin script.ts
```

**Programmatic (for custom build pipelines):**
```typescript
import thinkwellPlugin from "@thinkwell/bun-plugin";

await Bun.build({
  entrypoints: ["./src/index.ts"],
  outdir: "./dist",
  plugins: [thinkwellPlugin],
});
```

### Example Transformation

**Input** (`greeting.ts`):
```typescript
import { Agent } from "thinkwell:agent";
import { CLAUDE_CODE } from "thinkwell:connectors";

/**
 * A friendly greeting.
 * @JSONSchema
 */
export interface Greeting {
  /** The greeting message */
  message: string;
}

const agent = await Agent.connect(CLAUDE_CODE);
const result = await agent.think(Greeting.Schema).text("Hi").run();
```

**After Plugin** (what Bun sees):
```typescript
import { Agent } from "thinkwell:agent";
import { CLAUDE_CODE } from "thinkwell:connectors";

/**
 * A friendly greeting.
 * @JSONSchema
 */
export interface Greeting {
  /** The greeting message */
  message: string;
}

const agent = await Agent.connect(CLAUDE_CODE);
const result = await agent.think(Greeting.Schema).text("Hi").run();

// Auto-generated by @thinkwell/bun-plugin
import type { SchemaProvider, JsonSchema } from "thinkwell:acp";

namespace Greeting {
  export const Schema: SchemaProvider<Greeting> = {
    toJsonSchema: () => ({
      "type": "object",
      "properties": {
        "message": {
          "type": "string",
          "description": "The greeting message"
        }
      },
      "required": ["message"],
      "additionalProperties": false,
      "description": "A friendly greeting."
    }) as JsonSchema,
  };
}
```

The `thinkwell:agent` and `thinkwell:connectors` imports are resolved by the plugin's `onResolve` hook to bundled modules. The injected `thinkwell:acp` import for `SchemaProvider` is also resolved the same way.

### TypeScript Language Service Integration

For IDE support (autocomplete, type checking), we need TypeScript to understand that `Greeting.Schema` exists. Two approaches:

#### Approach A: Ambient Declaration File

Generate a `.d.ts` file that declares the namespace:

```typescript
// greeting.thinkwell.d.ts (auto-generated, gitignored)
import type { SchemaProvider } from "thinkwell:acp";
import type { Greeting } from "./greeting.js";

declare namespace Greeting {
  export const Schema: SchemaProvider<Greeting>;
}
```

The plugin can generate these on first load and update them when types change.

#### Approach B: TypeScript Plugin

A TypeScript language service plugin that provides virtual declarations:

```json
// tsconfig.json
{
  "compilerOptions": {
    "plugins": [{ "name": "@thinkwell/ts-plugin" }]
  }
}
```

This approach provides a better IDE experience but requires additional tooling.

**Recommendation**: Start with Approach A (ambient declarations). It's simpler and works immediately. Add a TS plugin later if needed.

## Performance Considerations

### Startup Latency

The plugin adds latency to first file load:
1. **Fast path check**: ~0.1ms (string search for `@JSONSchema`)
2. **TypeScript parse**: ~5-20ms per file
3. **Schema generation**: ~10-50ms per type

For a typical script with 1-3 types, expect ~50-100ms additional startup time.

### Caching Strategy

To minimize repeat work:

```typescript
const schemaCache = new Map<string, { mtime: number; schemas: Map<string, object> }>();

build.onLoad({ filter: /\.tsx?$/ }, async ({ path }) => {
  const stat = await Bun.file(path).stat();
  const cached = schemaCache.get(path);

  if (cached && cached.mtime === stat.mtime) {
    // Use cached schemas
    return generateOutput(cached.schemas);
  }

  // Generate fresh and cache
  const schemas = generateSchemas(path);
  schemaCache.set(path, { mtime: stat.mtime, schemas });
  return generateOutput(schemas);
});
```

### Parallel Type Checking

For projects with many `@JSONSchema` types, we can use Bun's worker threads:

```typescript
// Future optimization
const worker = new Worker("./schema-worker.ts");
const schemas = await worker.generateSchemas(path, typeNames);
```

## Limitations

### 1. Bun-Only

This approach only works with Bun. Users of Node.js, Deno, or other runtimes must use the existing `build-schema-providers` approach.

**Mitigation**: The build tool remains available. This plugin is an additional convenience, not a replacement.

### 2. No Cross-File Type Resolution (Initial Version)

The initial implementation handles types defined in the same file. Types imported from other files require the TypeScript program API:

```typescript
// This works
/** @JSONSchema */
interface Greeting { message: string; }

// This requires more work
import { BaseType } from "./types.js";
/** @JSONSchema */
interface Greeting extends BaseType { message: string; }
```

**Mitigation**: Use `ts.createProgram()` with all project files for full type resolution. This adds startup cost but enables full type support.

### 3. Declaration Merging Complexity

TypeScript's namespace declaration merging has edge cases:

```typescript
// User's code
interface Greeting { message: string; }
namespace Greeting {
  export function create(): Greeting { return { message: "hi" }; }
}

// Plugin adds
namespace Greeting {
  export const Schema: SchemaProvider<Greeting> = { ... };
}
```

This should work (namespaces merge), but needs testing with various patterns.

### 4. Source Maps

Injecting code at the end of the file may affect source map accuracy for errors in injected code. This is acceptable since:
- Errors in generated code are rare
- Stack traces for user code remain accurate

## Alternatives Considered

### 1. TypeScript Transformer Plugin (ts-patch)

Use ts-patch to hook into the TypeScript compiler directly.

**Pros**: Works with tsc, full type information
**Cons**:
- Won't work with TypeScript 7/tsgo (no transformer API)
- Requires patching TypeScript installation
- More complex setup

**Decision**: Rejected. TypeScript 7 is coming in early 2026, and Microsoft has indicated [transformer plugins won't be supported](https://github.com/microsoft/typescript-go/issues/516).

### 2. Bun Macros

Use Bun's macro system for compile-time schema generation:

```typescript
import { schemaFor } from "@thinkwell/macros" with { type: "macro" };

interface Greeting { message: string; }
const GreetingSchema = schemaFor<Greeting>();  // Evaluated at bundle time
```

**Pros**: Native Bun feature, no plugin needed
**Cons**:
- Macros can't access generic type parameters at compile time
- Would require passing type name as string: `schemaFor("Greeting")`
- Less ergonomic than namespace pattern

**Decision**: Rejected. The namespace pattern (`Greeting.Schema`) is more idiomatic.

### 3. Keep Build Step Only

Continue requiring `build-schema-providers` for all use cases.

**Pros**: Works everywhere, no runtime overhead
**Cons**: Friction for scripting use case, ceremony for small projects

**Decision**: Keep build tool for production, add plugin for development/scripting.

## Implementation Plan

See [plan.md](../plan.md) for the detailed implementation checklist.

## Package Structure

```
packages/
  bun-plugin/              # @thinkwell/bun-plugin
    src/
      index.ts             # Plugin entry point
      transform.ts         # Source transformation logic
      schema-cache.ts      # Caching layer
      declarations.ts      # .d.ts file generation
    package.json
    README.md

  cli/                     # thinkwell (npm: thinkwell)
    src/
      index.ts             # CLI entry point
      commands/
        run.ts             # Default command: run a script
    bin/
      thinkwell            # npm bin entry (Node.js launcher)
    package.json           # depends on @thinkwell/bun-plugin
    README.md
```

### CLI Package Details

```json
// packages/cli/package.json
{
  "name": "thinkwell",
  "version": "0.1.0",
  "bin": {
    "thinkwell": "./bin/thinkwell"
  },
  "dependencies": {
    "@thinkwell/bun-plugin": "workspace:*"
  }
}
```

The `bin/thinkwell` launcher detects the environment and delegates appropriately:

```bash
#!/usr/bin/env node
// Detect if bun is available, delegate with plugin preload
const { execSync, spawn } = require("child_process");
const path = require("path");

try {
  execSync("bun --version", { stdio: "ignore" });
} catch {
  console.error("Error: Bun is required. Install it from https://bun.sh");
  process.exit(1);
}

const pluginPath = path.resolve(__dirname, "../node_modules/@thinkwell/bun-plugin");
const args = process.argv.slice(2);

spawn("bun", ["--preload", pluginPath, ...args], { stdio: "inherit" })
  .on("exit", (code) => process.exit(code ?? 0));
```

## Security Considerations

- **File access**: Plugin only reads files Bun would already load
- **Code injection**: Injected code is deterministic from type definitions
- **No network**: All processing is local

## Testing Strategy

1. **Unit tests**: Schema generation, namespace injection
2. **Integration tests**: Full plugin with Bun.build
3. **Snapshot tests**: Verify output for various type patterns
4. **Comparison tests**: Ensure parity with build-schema-providers output

## Open Questions

1. **Should the plugin work in production builds?**

   The plugin adds latency. For production, users might prefer pre-generated schemas. Options:
   - Always use plugin (simplicity)
   - Environment-based: plugin in dev, build tool in prod
   - Add `thinkwell build` command that pre-generates schemas

2. **How should we handle schema generation errors?**

   If a type can't be converted to JSON Schema:
   - Throw at load time (fail fast)
   - Log warning and skip (permissive)
   - Generate a permissive schema with `additionalProperties: true`

3. **Should we support other runtimes via similar plugins?**

   Deno has a similar plugin system. Node.js has loaders. Worth exploring after Bun version is stable.

4. **Future CLI commands?**

   The `thinkwell` CLI could grow to include:
   - `thinkwell build` - Bundle for production with pre-generated schemas
   - `thinkwell init` - Scaffold a new thinkwell project
   - `thinkwell check` - Validate types and schemas without running

## Future Work

### Node.js Runtime Support

While this RFD focuses on Bun as the primary runtime, Node.js support is technically feasible using Node's experimental module hooks API (`registerHooks` from `node:module`). This section documents the investigation and potential implementation strategy.

#### What's Portable

Most of the core plugin logic is already Node.js-compatible:

- **Schema generation** (`ts-json-schema-generator`) - Pure Node.js library
- **TypeScript AST parsing** (`typescript` compiler API) - Works in Node.js
- **Code generation and injection** - Pure string manipulation
- **Program caching** - Uses `node:fs` and `node:path`

#### Bun-Specific APIs Requiring Replacement

| Bun API | Node.js Equivalent |
|---------|-------------------|
| `Bun.Transpiler` | `esbuild.transformSync()` or `swc` |
| `Bun.file(path).text()` | `fs.readFileSync(path, 'utf-8')` |
| `Bun.file(path).stat()` | `fs.statSync(path)` |
| `plugin()` from "bun" | `registerHooks()` from "node:module" |

#### Node.js Loader Implementation Sketch

```javascript
// @thinkwell/node-loader
import { registerHooks } from 'node:module';
import { readFileSync, statSync } from 'node:fs';
import { fileURLToPath } from 'node:url';
import esbuild from 'esbuild';

// Reuse portable modules from bun-plugin
import { findMarkedTypes } from './transform.js';
import { generateSchemas } from './schema-generator.js';
import { generateInsertions, generateImport, applyInsertions } from './codegen.js';
import { THINKWELL_MODULES } from './modules.js';

registerHooks({
  resolve(specifier, context, nextResolve) {
    if (specifier.startsWith('thinkwell:')) {
      const moduleName = specifier.slice(10);
      const npmPackage = THINKWELL_MODULES[moduleName];
      if (npmPackage) {
        return nextResolve(npmPackage, context);
      }
    }
    return nextResolve(specifier, context);
  },

  load(url, context, nextLoad) {
    if (!url.endsWith('.ts') && !url.endsWith('.tsx')) {
      return nextLoad(url, context);
    }

    const filePath = fileURLToPath(url);
    let source = readFileSync(filePath, 'utf-8');

    // Rewrite thinkwell:* imports
    source = rewriteThinkwellImports(source);

    // Check for @JSONSchema
    if (!source.includes('@JSONSchema')) {
      const js = esbuild.transformSync(source, { loader: 'ts' }).code;
      return { source: js, format: 'module', shortCircuit: true };
    }

    // Generate schemas and inject
    const types = findMarkedTypes(filePath, source);
    const schemas = generateSchemas(filePath, types);
    const insertions = generateInsertions(types, schemas);
    let modified = applyInsertions(source, insertions);
    modified = generateImport() + '\n' + modified;

    const js = esbuild.transformSync(modified, { loader: 'ts' }).code;
    return { source: js, format: 'module', shortCircuit: true };
  }
});
```

#### CLI Runtime Selection Strategy

When adding Node.js support to the CLI, there are several options for selecting which runtime to use:

**Option 1: Autodetect**

The CLI automatically detects which runtimes are available and selects one:
- If running under Bun (detected via `process.versions.bun`), use Bun
- If running under Node.js and Bun is installed, prefer Bun
- If only Node.js is available, use the Node.js loader

Pros: Zero configuration, "just works"
Cons: May surprise users if behavior differs between environments

**Option 2: Environment Variable with Bun Default**

Use an environment variable (e.g., `THINKWELL_RUNTIME`) to explicitly select the runtime:
- `THINKWELL_RUNTIME=bun` - Use Bun (requires Bun installed)
- `THINKWELL_RUNTIME=node` - Use Node.js with the node-loader
- If unset, default to Bun (error if not installed)

Pros: Explicit, predictable, easy to configure in CI/CD
Cons: Requires configuration for Node.js users

**Option 3: Hybrid (Recommended)**

Combine Options 1 and 2:
- `THINKWELL_RUNTIME=bun` - Use Bun
- `THINKWELL_RUNTIME=node` - Use Node.js
- `THINKWELL_RUNTIME=auto` - Autodetect (Option 1 behavior)
- If unset, default to Bun

This provides explicit control when needed while allowing autodetection as an opt-in feature.

#### Trade-offs

| Factor | Bun | Node.js |
|--------|-----|---------|
| TypeScript support | Native | Requires esbuild/swc |
| Performance | Fast | ~20-50% slower |
| API stability | Stable | `registerHooks` is experimental |
| Deployment | Requires Bun | More universally available |

#### Alternative: Build-Time Only for Node.js

Instead of full runtime support, Node.js users could use a build-time workflow:
- Run `thinkwell build` (or existing `build-schema-providers`) to pre-generate schemas
- Execute the built output with plain Node.js

This mirrors how most TypeScript tooling works with Node.js today.

#### Recommendation

Implement Node.js runtime support in a follow-up PR with:
1. A new `@thinkwell/node-loader` package sharing code with `bun-plugin`
2. Option 3 (hybrid) runtime selection in the CLI
3. Documentation for both runtime and build-time Node.js workflows

## References

- [Bun Plugin API](https://bun.sh/docs/bundler/plugins)
- [Bun Runtime Plugins](https://bun.sh/docs/runtime/plugins)
- [Bun Build --compile](https://bun.sh/docs/bundler/executables)
- [Node.js Module Customization Hooks](https://nodejs.org/api/module.html#customization-hooks)
- [ts-json-schema-generator](https://github.com/vega/ts-json-schema-generator)
- [TypeScript Compiler API](https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API)
- [TypeScript-Go Issue #516: Transformer Plugin Support](https://github.com/microsoft/typescript-go/issues/516)
- [RFD: Schema Provider Interface](./schema-providers.md)
