# RFD: Thinkwell CLI and Bun Plugin for Automatic Schema Generation

## Summary

This document proposes a `thinkwell` CLI and accompanying Bun plugin that automatically generates JSON Schema definitions from TypeScript types marked with `@JSONSchema`, eliminating the need for separate schema files or explicit build steps. The CLI wraps Bun with the plugin pre-configured, enabling a zero-configuration scripting experience.

## Motivation

### Current State

Today, using typed schemas with thinkwell requires a multi-step workflow:

```typescript
// greeting.ts - hand-written
/** @JSONSchema */
export interface Greeting {
  message: string;
}

namespace Greeting {
  export const Schema = GreetingSchema;  // Import from generated file
}

// greeting.schemas.ts - generated by build-schema-providers
export const GreetingSchema: SchemaProvider<Greeting> = { ... };
```

Users must:
1. Run `build-schema-providers` as a separate build step
2. Import the generated schema from a companion file
3. Wire up the namespace manually

This friction is acceptable for larger projects but creates unnecessary ceremony for quick scripts and prototypes.

### Vision: Scripting with Thinkwell

With Bun gaining traction as an AI runtime (recently acquired by Anthropic), there's an opportunity to make thinkwell scripts as simple as:

```typescript
#!/usr/bin/env thinkwell
// hello.ts

import { Agent } from "thinkwell:agent";
import { CLAUDE_CODE } from "thinkwell:connectors";

/** @JSONSchema */
interface Greeting {
  /** The greeting message */
  message: string;
}

const agent = await Agent.connect(CLAUDE_CODE);
const greeting: Greeting = await agent
  .think(Greeting.Schema)  // Schema is automatically available!
  .text("Say hello")
  .run();

console.log(greeting.message);
```

Run with just:
```bash
thinkwell hello.ts
```

Or make it executable:
```bash
chmod +x hello.ts
./hello.ts
```

No build step. No configuration files. No generated files. No `package.json` required. The schema materializes automatically, and thinkwell modules are built-in.

### The `thinkwell:*` URI Scheme

Thinkwell scripts use a custom URI scheme for imports, similar to Node.js's `node:*` and Bun's `bun:*` built-in modules:

```typescript
import { Agent } from "thinkwell:agent";
import { CLAUDE_CODE } from "thinkwell:connectors";
import type { SchemaProvider } from "thinkwell:acp";
```

This design provides several benefits:

1. **Zero configuration**: Users don't need a `package.json` or `node_modules` - modules are built into the runtime
2. **Explicit built-in signal**: The `thinkwell:` prefix clearly indicates these are provided by the runtime, not user dependencies
3. **Familiar pattern**: Follows the established convention of `node:fs`, `bun:test`, etc.
4. **Version consistency**: All thinkwell modules are versioned together with the CLI

The plugin registers an `onResolve` hook that intercepts `thinkwell:*` imports and resolves them to bundled modules shipped with the CLI.

## Design Goals

1. **Zero configuration**: `thinkwell script.ts` just works
2. **Transparent integration**: Types remain hand-written; schemas appear magically
3. **Type safety**: Full TypeScript type checking preserved
4. **Development velocity**: Changes to types immediately reflected without rebuild
5. **Future-proof**: Works with TypeScript 7/tsgo (uses TS Compiler API separately)
6. **Extensible CLI**: Foundation for future commands (`thinkwell build`, `thinkwell init`)

## Proposal

### The `thinkwell` CLI

The primary user interface is the `thinkwell` command, a thin wrapper around Bun that automatically loads the schema generation plugin:

```bash
thinkwell script.ts           # Run a script
thinkwell run script.ts       # Explicit run subcommand (equivalent)
./script.ts                   # Via shebang: #!/usr/bin/env thinkwell
```

#### Distribution

The CLI is distributed as an npm package that requires Bun to be installed:

```bash
npm install -g @thinkwell/cli
# or
bun install -g @thinkwell/cli
```

The package includes a Node.js launcher script (`bin/thinkwell`) that delegates to Bun with the plugin preloaded. This allows the CLI to be installed via npm/pnpm while using Bun as the actual runtime.

### Module Resolution

The plugin uses Bun's `onResolve` hook to intercept `thinkwell:*` imports and resolve them to the corresponding npm packages.

Available built-in modules:

| Import | Description |
|--------|-------------|
| `thinkwell:agent` | Core `Agent` class for interacting with AI models |
| `thinkwell:acp` | ACP types including `SchemaProvider`, `JsonSchema` |
| `thinkwell:connectors` | Pre-configured connectors like `CLAUDE_CODE` |
| `thinkwell:protocol` | Low-level protocol types |

### Plugin Architecture

The plugin uses Bun's `onLoad` hook to intercept TypeScript files and inject schema definitions:

```
                                    ┌─────────────────┐
                                    │  TypeScript     │
                                    │  Compiler API   │
                                    │  (type info)    │
                                    └────────┬────────┘
                                             │
┌──────────┐    ┌──────────────┐    ┌────────▼────────┐    ┌──────────┐
│  .ts     │───▶│  Bun onLoad  │───▶│  Schema         │───▶│ Modified │
│  source  │    │  intercept   │    │  Generator      │    │ .ts      │
└──────────┘    └──────────────┘    └────────┬────────┘    └──────────┘
                                             │
                                    ┌────────▼────────┐
                                    │ ts-json-schema- │
                                    │ generator       │
                                    └─────────────────┘
```

### Usage

#### Primary: The `thinkwell` CLI

```bash
# Run a script
thinkwell script.ts

# Or with shebang
#!/usr/bin/env thinkwell
```

This is the recommended approach for most users.

#### Alternative: Direct Bun Integration

For users who want to integrate the plugin into an existing Bun workflow:

**bunfig.toml:**
```toml
preload = ["@thinkwell/bun-plugin"]
```

**CLI flag:**
```bash
bun --preload @thinkwell/bun-plugin script.ts
```

**Programmatic (for custom build pipelines):**
```typescript
import thinkwellPlugin from "@thinkwell/bun-plugin";

await Bun.build({
  entrypoints: ["./src/index.ts"],
  outdir: "./dist",
  plugins: [thinkwellPlugin],
});
```

### Example Transformation

**Input** (`greeting.ts`):
```typescript
import { Agent } from "thinkwell:agent";
import { CLAUDE_CODE } from "thinkwell:connectors";

/**
 * A friendly greeting.
 * @JSONSchema
 */
export interface Greeting {
  /** The greeting message */
  message: string;
}

const agent = await Agent.connect(CLAUDE_CODE);
const result = await agent.think(Greeting.Schema).text("Hi").run();
```

**After Plugin** (what Bun sees):
```typescript
import { Agent } from "thinkwell:agent";
import { CLAUDE_CODE } from "thinkwell:connectors";

/**
 * A friendly greeting.
 * @JSONSchema
 */
export interface Greeting {
  /** The greeting message */
  message: string;
}

const agent = await Agent.connect(CLAUDE_CODE);
const result = await agent.think(Greeting.Schema).text("Hi").run();

// Auto-generated by @thinkwell/bun-plugin
import type { SchemaProvider, JsonSchema } from "thinkwell:acp";

namespace Greeting {
  export const Schema: SchemaProvider<Greeting> = {
    toJsonSchema: () => ({
      "type": "object",
      "properties": {
        "message": {
          "type": "string",
          "description": "The greeting message"
        }
      },
      "required": ["message"],
      "additionalProperties": false,
      "description": "A friendly greeting."
    }) as JsonSchema,
  };
}
```

The `thinkwell:agent` and `thinkwell:connectors` imports are resolved by the plugin's `onResolve` hook to bundled modules. The injected `thinkwell:acp` import for `SchemaProvider` is also resolved the same way.

### TypeScript Language Service Integration

For IDE support (autocomplete, type checking), the CLI generates ambient `.d.ts` files that declare the namespace:

```typescript
// greeting.thinkwell.d.ts (auto-generated, gitignored)
import type { SchemaProvider } from "@thinkwell/acp";
import type { Greeting } from "./greeting.js";

declare namespace Greeting {
  export const Schema: SchemaProvider<Greeting>;
}
```

Use `thinkwell types` to generate these files, or `thinkwell types --watch` to regenerate them automatically when source files change.

## Performance Considerations

### Startup Latency

The plugin adds latency to first file load:
1. **Fast path check**: ~0.1ms (string search for `@JSONSchema`)
2. **TypeScript parse**: ~5-20ms per file
3. **Schema generation**: ~10-50ms per type

For a typical script with 1-3 types, expect ~50-100ms additional startup time.

### Caching Strategy

The plugin uses mtime-based caching to avoid regenerating schemas for unchanged files. Additionally, the TypeScript program is cached per-project (keyed by tsconfig.json location) to amortize the cost of type resolution across multiple files.

## Limitations

### 1. Bun Runtime Required

While the `thinkwell` CLI can be invoked via Node.js (the launcher script is a Node.js ES module), it delegates to Bun for actual script execution. Users must have Bun installed.

For environments where Bun is not available, the existing `build-schema-providers` approach remains available as a build-time alternative.

### 2. Cross-File Type Resolution

Types that extend or reference types from other files are supported via `ts-json-schema-generator`'s program-based resolution. The plugin caches the TypeScript program per-project to minimize overhead.

### 3. Declaration Merging Complexity

TypeScript's namespace declaration merging has edge cases:

```typescript
// User's code
interface Greeting { message: string; }
namespace Greeting {
  export function create(): Greeting { return { message: "hi" }; }
}

// Plugin adds
namespace Greeting {
  export const Schema: SchemaProvider<Greeting> = { ... };
}
```

This should work (namespaces merge), but needs testing with various patterns.

### 4. Source Maps

Injecting code at the end of the file may affect source map accuracy for errors in injected code. This is acceptable since:
- Errors in generated code are rare
- Stack traces for user code remain accurate

## Alternatives Considered

### 1. TypeScript Transformer Plugin (ts-patch)

Use ts-patch to hook into the TypeScript compiler directly.

**Pros**: Works with tsc, full type information
**Cons**:
- Won't work with TypeScript 7/tsgo (no transformer API)
- Requires patching TypeScript installation
- More complex setup

**Decision**: Rejected. TypeScript 7 is coming in early 2026, and Microsoft has indicated [transformer plugins won't be supported](https://github.com/microsoft/typescript-go/issues/516).

### 2. Bun Macros

Use Bun's macro system for compile-time schema generation:

```typescript
import { schemaFor } from "@thinkwell/macros" with { type: "macro" };

interface Greeting { message: string; }
const GreetingSchema = schemaFor<Greeting>();  // Evaluated at bundle time
```

**Pros**: Native Bun feature, no plugin needed
**Cons**:
- Macros can't access generic type parameters at compile time
- Would require passing type name as string: `schemaFor("Greeting")`
- Less ergonomic than namespace pattern

**Decision**: Rejected. The namespace pattern (`Greeting.Schema`) is more idiomatic.

### 3. Keep Build Step Only

Continue requiring `build-schema-providers` for all use cases.

**Pros**: Works everywhere, no runtime overhead
**Cons**: Friction for scripting use case, ceremony for small projects

**Decision**: Keep build tool for production, add plugin for development/scripting.

### 4. TypeScript Language Service Plugin

A TypeScript language service plugin could provide virtual declarations without generating files:

```json
// tsconfig.json
{
  "compilerOptions": {
    "plugins": [{ "name": "@thinkwell/ts-plugin" }]
  }
}
```

**Pros**: Better IDE experience, no generated files to manage
**Cons**: Requires additional tooling, more complex implementation

**Decision**: Rejected for initial implementation. Ambient declaration files (`thinkwell types`) are simpler and work immediately. A TS plugin could be added later if needed.

### 5. Standalone Binary Distribution

Distribute the CLI as a standalone binary with Bun runtime embedded:

```bash
curl -fsSL https://thinkwell.dev/install.sh | bash
```

**Pros**: Single binary with no dependencies, good for CI/CD environments
**Cons**: Larger download (~50MB), more complex release process

**Decision**: Deferred. npm distribution is sufficient for initial release. Standalone binaries can be added later for CI/CD use cases.

## Package Structure

```
packages/
  bun-plugin/              # @thinkwell/bun-plugin
    src/
      index.ts             # Plugin entry point
      transform.ts         # AST utilities for finding @JSONSchema types
      codegen.ts           # Code generation for namespace injections
      schema-generator.ts  # Schema generation via ts-json-schema-generator
      schema-cache.ts      # Mtime-based caching layer
      program-cache.ts     # TypeScript program caching
      declarations.ts      # .d.ts file generation
      watcher.ts           # File watcher for --watch mode
      modules.ts           # thinkwell:* module mappings
      errors.ts            # Error types and diagnostic formatting
    package.json
    README.md

  cli/                     # @thinkwell/cli
    bin/
      thinkwell            # Node.js launcher that delegates to Bun
    src/
      types-command.ts     # Implementation of `thinkwell types`
    package.json           # depends on @thinkwell/bun-plugin
    README.md
```

## Security Considerations

- **File access**: Plugin only reads files Bun would already load
- **Code injection**: Injected code is deterministic from type definitions
- **No network**: All processing is local

## Testing Strategy

1. **Unit tests**: Schema generation, namespace injection
2. **Integration tests**: Full plugin with Bun.build
3. **Snapshot tests**: Verify output for various type patterns
4. **Comparison tests**: Ensure parity with build-schema-providers output

## Error Handling

The plugin uses fail-fast semantics with Rust/Cargo-style diagnostic formatting. Each error includes:
- An error code and summary on the first line
- Source location with file path and line number
- Quoted source context with line numbers
- Carets pointing to the relevant code
- A `help:` line with actionable fix suggestions

### Error Format

Errors follow a format inspired by Rust's compiler diagnostics:

```
error[E0001]: type `Foo` not found
 --> src/example.ts:2:1
  |
1 | /** @JSONSchema */
2 | interface Foo {
  | ^^^^^^^^^^^^^
  |
help: ensure the type is exported: `export interface Foo`
```

### ANSI Color Scheme

When output is a TTY, errors use ANSI colors for visual clarity:

| Element | Color | Style |
|---------|-------|-------|
| `error[E0001]:` | Red | Bold |
| Error message | White | Bold |
| Arrow (`-->`) | Bright Blue | Bold |
| File path | Default | Normal |
| Gutter (line numbers, `\|`) | Bright Blue | Bold |
| Source code | Default | Normal |
| Carets (`^^^`) | Yellow | Bold |
| `help:` | Green | Bold |
| Help message | Default | Normal |
| Inline code in help | Cyan | Normal |

### Error Codes

Each error type has a unique code for searchability and documentation:

| Code | Error Type |
|------|------------|
| E0001 | Type not found |
| E0002 | Circular type reference |
| E0003 | Unresolved generic type parameter |
| E0004 | Function type not representable in JSON Schema |
| E0005 | Symbol type not representable in JSON Schema |
| E0006 | BigInt type not representable in JSON Schema |
| E0007 | Complex conditional type |
| E0008 | Complex mapped type |
| E0009 | Template literal type cannot be enumerated |
| E0010 | TypeScript program creation failed |
| E0011 | File read error |
| E0012 | File write error |
| E0013 | Transpilation error (syntax error) |
| E0014 | Unknown thinkwell:* module |

### Source Context

The error formatter extracts source context by:
1. Reading the source file (already available during plugin execution)
2. Using the type's start position from the TypeScript AST
3. Showing 1-2 lines of context above the error line
4. Underlining the type name or declaration with carets

### Implementation Notes

The error formatting is implemented in `errors.ts` with:
- A `formatDiagnostic()` function that produces the formatted output
- TTY detection via `process.stdout.isTTY` to enable/disable colors
- Source location extraction from TypeInfo (already captured during parsing)
- Error codes as static properties on each error class

This approach ensures users immediately see problems with clear context rather than wading through verbose stack traces. The format is familiar to developers who use Rust, TypeScript, or other modern compilers.

## Future Work

### Additional CLI Commands

The `thinkwell` CLI could grow to include:

- **`thinkwell build`** - Bundle for production with pre-generated schemas, eliminating runtime startup latency
- **`thinkwell init`** - Scaffold a new thinkwell project
- **`thinkwell check`** - Validate types and schemas without running

### Node.js Runtime Support

While this RFD focuses on Bun as the primary runtime, Node.js support is technically feasible using Node's experimental module hooks API (`registerHooks` from `node:module`). This section documents the investigation and potential implementation strategy.

#### What's Portable

Most of the core plugin logic is already Node.js-compatible:

- **Schema generation** (`ts-json-schema-generator`) - Pure Node.js library
- **TypeScript AST parsing** (`typescript` compiler API) - Works in Node.js
- **Code generation and injection** - Pure string manipulation
- **Program caching** - Uses `node:fs` and `node:path`

#### Bun-Specific APIs Requiring Replacement

| Bun API | Node.js Equivalent |
|---------|-------------------|
| `Bun.Transpiler` | `esbuild.transformSync()` or `swc` |
| `Bun.file(path).text()` | `fs.readFileSync(path, 'utf-8')` |
| `Bun.file(path).stat()` | `fs.statSync(path)` |
| `plugin()` from "bun" | `registerHooks()` from "node:module" |

#### Node.js Loader Implementation Sketch

```javascript
// @thinkwell/node-loader
import { registerHooks } from 'node:module';
import { readFileSync, statSync } from 'node:fs';
import { fileURLToPath } from 'node:url';
import esbuild from 'esbuild';

// Reuse portable modules from bun-plugin
import { findMarkedTypes } from './transform.js';
import { generateSchemas } from './schema-generator.js';
import { generateInsertions, generateImport, applyInsertions } from './codegen.js';
import { THINKWELL_MODULES } from './modules.js';

registerHooks({
  resolve(specifier, context, nextResolve) {
    if (specifier.startsWith('thinkwell:')) {
      const moduleName = specifier.slice(10);
      const npmPackage = THINKWELL_MODULES[moduleName];
      if (npmPackage) {
        return nextResolve(npmPackage, context);
      }
    }
    return nextResolve(specifier, context);
  },

  load(url, context, nextLoad) {
    if (!url.endsWith('.ts') && !url.endsWith('.tsx')) {
      return nextLoad(url, context);
    }

    const filePath = fileURLToPath(url);
    let source = readFileSync(filePath, 'utf-8');

    // Rewrite thinkwell:* imports
    source = rewriteThinkwellImports(source);

    // Check for @JSONSchema
    if (!source.includes('@JSONSchema')) {
      const js = esbuild.transformSync(source, { loader: 'ts' }).code;
      return { source: js, format: 'module', shortCircuit: true };
    }

    // Generate schemas and inject
    const types = findMarkedTypes(filePath, source);
    const schemas = generateSchemas(filePath, types);
    const insertions = generateInsertions(types, schemas);
    let modified = applyInsertions(source, insertions);
    modified = generateImport() + '\n' + modified;

    const js = esbuild.transformSync(modified, { loader: 'ts' }).code;
    return { source: js, format: 'module', shortCircuit: true };
  }
});
```

#### CLI Runtime Selection Strategy

When adding Node.js support to the CLI, there are several options for selecting which runtime to use:

**Option 1: Autodetect**

The CLI automatically detects which runtimes are available and selects one:
- If running under Bun (detected via `process.versions.bun`), use Bun
- If running under Node.js and Bun is installed, prefer Bun
- If only Node.js is available, use the Node.js loader

Pros: Zero configuration, "just works"
Cons: May surprise users if behavior differs between environments

**Option 2: Environment Variable with Bun Default**

Use an environment variable (e.g., `THINKWELL_RUNTIME`) to explicitly select the runtime:
- `THINKWELL_RUNTIME=bun` - Use Bun (requires Bun installed)
- `THINKWELL_RUNTIME=node` - Use Node.js with the node-loader
- If unset, default to Bun (error if not installed)

Pros: Explicit, predictable, easy to configure in CI/CD
Cons: Requires configuration for Node.js users

**Option 3: Hybrid (Recommended)**

Combine Options 1 and 2:
- `THINKWELL_RUNTIME=bun` - Use Bun
- `THINKWELL_RUNTIME=node` - Use Node.js
- `THINKWELL_RUNTIME=auto` - Autodetect (Option 1 behavior)
- If unset, default to Bun

This provides explicit control when needed while allowing autodetection as an opt-in feature.

#### Trade-offs

| Factor | Bun | Node.js |
|--------|-----|---------|
| TypeScript support | Native | Requires esbuild/swc |
| Performance | Fast | ~20-50% slower |
| API stability | Stable | `registerHooks` is experimental |
| Deployment | Requires Bun | More universally available |

#### Alternative: Build-Time Only for Node.js

Instead of full runtime support, Node.js users could use a build-time workflow:
- Run `thinkwell build` (or existing `build-schema-providers`) to pre-generate schemas
- Execute the built output with plain Node.js

This mirrors how most TypeScript tooling works with Node.js today.

#### Recommendation

Implement Node.js runtime support in a follow-up PR with:
1. A new `@thinkwell/node-loader` package sharing code with `bun-plugin`
2. Option 3 (hybrid) runtime selection in the CLI
3. Documentation for both runtime and build-time Node.js workflows

## References

- [Bun Plugin API](https://bun.sh/docs/bundler/plugins)
- [Bun Runtime Plugins](https://bun.sh/docs/runtime/plugins)
- [Bun Build --compile](https://bun.sh/docs/bundler/executables)
- [Node.js Module Customization Hooks](https://nodejs.org/api/module.html#customization-hooks)
- [ts-json-schema-generator](https://github.com/vega/ts-json-schema-generator)
- [TypeScript Compiler API](https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API)
- [TypeScript-Go Issue #516: Transformer Plugin Support](https://github.com/microsoft/typescript-go/issues/516)
- [RFD: Schema Provider Interface](./schema-providers.md)
