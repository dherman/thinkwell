# RFD: Thinkwell CLI and Bun Plugin for Automatic Schema Generation

## Summary

This document proposes a `thinkwell` CLI and accompanying Bun plugin that automatically generates JSON Schema definitions from TypeScript types marked with `@JSONSchema`, eliminating the need for separate schema files or explicit build steps. The CLI wraps Bun with the plugin pre-configured, providing a zero-configuration development experience for both standalone scripts and larger projects.

## Motivation

### Current State

Today, using typed schemas with thinkwell requires a multi-step workflow:

```typescript
// greeting.ts - hand-written
/** @JSONSchema */
export interface Greeting {
  message: string;
}

namespace Greeting {
  export const Schema = GreetingSchema;  // Import from generated file
}

// greeting.schemas.ts - generated by build-schema-providers
export const GreetingSchema: SchemaProvider<Greeting> = { ... };
```

Users must:
1. Run `build-schema-providers` as a separate build step
2. Import the generated schema from a companion file
3. Wire up the namespace manually

This friction creates unnecessary ceremony for development workflows.

### Vision: Zero-Configuration Development

With Bun gaining traction as an AI runtime (recently acquired by Anthropic), there's an opportunity to eliminate this ceremony entirely. The `thinkwell` CLI provides a unified runtime that works identically for standalone scripts and larger projects:

```typescript
#!/usr/bin/env thinkwell
// hello.ts

import { Agent } from "thinkwell:agent";
import { CLAUDE_CODE } from "thinkwell:connectors";

/** @JSONSchema */
interface Greeting {
  /** The greeting message */
  message: string;
}

const agent = await Agent.connect(CLAUDE_CODE);
const greeting: Greeting = await agent
  .think(Greeting.Schema)  // Schema is automatically available!
  .text("Say hello")
  .run();

console.log(greeting.message);
```

Run with just:
```bash
thinkwell hello.ts
```

Or make it executable:
```bash
chmod +x hello.ts
./hello.ts
```

No build step. No configuration files. No generated files. The schema materializes automatically, and thinkwell modules are built-in.

This same code works identically whether it's a standalone script or part of a larger project with `package.json`. The only differences between scripts and projects are:

| Aspect | Script (no manifest) | Project (with manifest) |
|--------|---------------------|------------------------|
| Invocation | `#!/usr/bin/env thinkwell` or `thinkwell script.ts` | `thinkwell src/main.ts` |
| Dependencies | Built-in only (`thinkwell:*`) | Built-in + npm packages |
| Type checking | Via tsconfig integration (see Future Work) | Via tsconfig integration |

Adding a `package.json` doesn't require changing your imports or switching runtimes—the `thinkwell` CLI remains the primary way to run thinkwell code.

### The `thinkwell:*` URI Scheme

Thinkwell code uses a custom URI scheme for imports, similar to Node.js's `node:*` and Bun's `bun:*` built-in modules:

```typescript
import { Agent } from "thinkwell:agent";
import { CLAUDE_CODE } from "thinkwell:connectors";
import type { SchemaProvider } from "thinkwell:acp";
```

This design provides several benefits:

1. **Zero configuration**: Scripts don't need a `package.json` or `node_modules`; projects can use `thinkwell:*` alongside npm dependencies
2. **Explicit built-in signal**: The `thinkwell:` prefix clearly indicates these are provided by the runtime, not user dependencies
3. **Familiar pattern**: Follows the established convention of `node:fs`, `bun:test`, etc.
4. **Version consistency**: All thinkwell modules are versioned together with the CLI

The plugin registers an `onResolve` hook that intercepts `thinkwell:*` imports and resolves them to bundled modules shipped with the CLI.

#### When to Use npm-Style Imports

While `thinkwell:*` URIs are the recommended approach, there are valid reasons to use npm-style imports (`@thinkwell/agent` instead of `thinkwell:agent`):

1. **IDE type acquisition** — If your editor doesn't have the thinkwell TS plugin (see Future Work), npm packages provide types automatically via `node_modules`
2. **Bundling for non-Bun targets** — Standard imports work with any bundler when targeting Node.js or browsers
3. **Explicit version pinning** — `package.json` gives fine-grained control over exact versions

These are opt-in trade-offs for specific use cases, not the default path.

## Design Goals

1. **Zero configuration**: `thinkwell script.ts` just works
2. **Transparent integration**: Types remain hand-written; schemas appear magically
3. **Type safety**: Full TypeScript type checking preserved
4. **Development velocity**: Changes to types immediately reflected without rebuild
5. **Future-proof**: Works with TypeScript 7/tsgo (uses TS Compiler API separately)
6. **Extensible CLI**: Foundation for future commands (`thinkwell build`, `thinkwell init`)

## Proposal

### The `thinkwell` CLI

The primary user interface is the `thinkwell` command, a thin wrapper around Bun that automatically loads the schema generation plugin:

```bash
thinkwell script.ts           # Run a script
thinkwell run script.ts       # Explicit run subcommand (equivalent)
./script.ts                   # Via shebang: #!/usr/bin/env thinkwell
```

#### Distribution

The CLI is distributed as an npm package that requires Bun to be installed:

```bash
npm install -g @thinkwell/cli
# or
bun install -g @thinkwell/cli
```

The package includes a Node.js launcher script (`bin/thinkwell`) that delegates to Bun with the plugin preloaded. This allows the CLI to be installed via npm/pnpm while using Bun as the actual runtime.

### Module Resolution

The plugin uses Bun's `onResolve` hook to intercept `thinkwell:*` imports and resolve them to the corresponding npm packages.

Available built-in modules:

| Import | Description |
|--------|-------------|
| `thinkwell:agent` | Core `Agent` class for interacting with AI models |
| `thinkwell:acp` | ACP types including `SchemaProvider`, `JsonSchema` |
| `thinkwell:connectors` | Pre-configured connectors like `CLAUDE_CODE` |
| `thinkwell:protocol` | Low-level protocol types |

### Plugin Architecture

The plugin uses Bun's `onLoad` hook to intercept TypeScript files and inject schema definitions:

```
                                    ┌─────────────────┐
                                    │  TypeScript     │
                                    │  Compiler API   │
                                    │  (type info)    │
                                    └────────┬────────┘
                                             │
┌──────────┐    ┌──────────────┐    ┌────────▼────────┐    ┌──────────┐
│  .ts     │───▶│  Bun onLoad  │───▶│  Schema         │───▶│ Modified │
│  source  │    │  intercept   │    │  Generator      │    │ .ts      │
└──────────┘    └──────────────┘    └────────┬────────┘    └──────────┘
                                             │
                                    ┌────────▼────────┐
                                    │ ts-json-schema- │
                                    │ generator       │
                                    └─────────────────┘
```

### Usage

#### Primary: The `thinkwell` CLI

```bash
# Run a script
thinkwell script.ts

# Or with shebang
#!/usr/bin/env thinkwell
```

This is the recommended approach for most users.

#### Alternative: Direct Bun Integration

For advanced users who want to use `bun` directly (without the `thinkwell` CLI wrapper) or integrate schema generation into an existing Bun workflow:

**bunfig.toml:**
```toml
preload = ["@thinkwell/bun-plugin"]
```

**CLI flag:**
```bash
bun --preload @thinkwell/bun-plugin script.ts
```

**Programmatic (for custom build pipelines):**
```typescript
import thinkwellPlugin from "@thinkwell/bun-plugin";

await Bun.build({
  entrypoints: ["./src/index.ts"],
  outdir: "./dist",
  plugins: [thinkwellPlugin],
});
```

### Example Transformation

**Input** (`greeting.ts`):
```typescript
import { Agent } from "thinkwell:agent";
import { CLAUDE_CODE } from "thinkwell:connectors";

/**
 * A friendly greeting.
 * @JSONSchema
 */
export interface Greeting {
  /** The greeting message */
  message: string;
}

const agent = await Agent.connect(CLAUDE_CODE);
const result = await agent.think(Greeting.Schema).text("Hi").run();
```

**After Plugin** (what Bun sees):
```typescript
// Auto-generated import (added at top of file)
import type * as $$__thinkwell__acp__$$ from "@thinkwell/acp";

import { Agent } from "thinkwell:agent";
import { CLAUDE_CODE } from "thinkwell:connectors";

/**
 * A friendly greeting.
 * @JSONSchema
 */
export interface Greeting {
  /** The greeting message */
  message: string;
}
namespace Greeting {
  export const Schema: $$__thinkwell__acp__$$.SchemaProvider<Greeting> = {
    toJsonSchema: () => ({
      "type": "object",
      "properties": {
        "message": {
          "type": "string",
          "description": "The greeting message"
        }
      },
      "required": ["message"],
      "additionalProperties": false,
      "description": "A friendly greeting."
    }) as $$__thinkwell__acp__$$.JsonSchema,
  };
}

const agent = await Agent.connect(CLAUDE_CODE);
const result = await agent.think(Greeting.Schema).text("Hi").run();
```

The `thinkwell:agent` and `thinkwell:connectors` imports are resolved by the plugin's `onResolve` hook to bundled modules.

Note: The `import type` statement must be at module scope rather than nested inside the namespace because TypeScript prohibits import declarations inside namespaces that reference external modules (error TS1147). The mangled namespace name `$$__thinkwell__acp__$$` avoids polluting the module scope with identifiers that could conflict with user code.

## Performance Considerations

### Startup Latency

The plugin adds latency to first file load:
1. **Fast path check**: ~0.1ms (string search for `@JSONSchema`)
2. **TypeScript parse**: ~5-20ms per file
3. **Schema generation**: ~10-50ms per type

For a typical script with 1-3 types, expect ~50-100ms additional startup time.

### Caching Strategy

The plugin uses mtime-based caching to avoid regenerating schemas for unchanged files. Additionally, the TypeScript program is cached per-project (keyed by tsconfig.json location) to amortize the cost of type resolution across multiple files.

## Limitations

### 1. Bun Runtime Required

While the `thinkwell` CLI can be invoked via Node.js (the launcher script is a Node.js ES module), it delegates to Bun for actual script execution. Users must have Bun installed.

For environments where Bun is not available, the existing `build-schema-providers` approach remains available as a build-time alternative.

### 2. Cross-File Type Resolution

Types that extend or reference types from other files are supported via `ts-json-schema-generator`'s program-based resolution. The plugin caches the TypeScript program per-project to minimize overhead.

### 3. Source Maps

Injecting code at the end of the file may affect source map accuracy for errors in injected code. This is acceptable since:
- Errors in generated code are rare
- Stack traces for user code remain accurate

## Alternatives Considered

### 1. TypeScript Transformer Plugin (ts-patch)

Use ts-patch to hook into the TypeScript compiler directly.

**Pros**: Works with tsc, full type information
**Cons**:
- Won't work with TypeScript 7/tsgo (no transformer API)
- Requires patching TypeScript installation
- More complex setup

**Decision**: Rejected. TypeScript 7 is coming in early 2026, and Microsoft has indicated [transformer plugins won't be supported](https://github.com/microsoft/typescript-go/issues/516).

### 2. Bun Macros

Use Bun's macro system for compile-time schema generation:

```typescript
import { schemaFor } from "@thinkwell/macros" with { type: "macro" };

interface Greeting { message: string; }
const GreetingSchema = schemaFor<Greeting>();  // Evaluated at bundle time
```

**Pros**: Native Bun feature, no plugin needed
**Cons**:
- Macros can't access generic type parameters at compile time
- Would require passing type name as string: `schemaFor("Greeting")`
- Less ergonomic than namespace pattern

**Decision**: Rejected. The namespace pattern (`Greeting.Schema`) is more idiomatic.

### 3. Keep Build Step Only

Continue requiring `build-schema-providers` for all use cases.

**Pros**: Works everywhere, no runtime overhead
**Cons**: Friction for development workflows, ceremony for all project sizes

**Decision**: The `thinkwell` CLI becomes the primary runtime for development. The build tool remains available for production optimization via `thinkwell build` (see Future Work).

### 4. TypeScript Language Service Plugin

A TypeScript language service plugin could provide virtual declarations without generating files:

```json
// tsconfig.json
{
  "compilerOptions": {
    "plugins": [{ "name": "@thinkwell/ts-plugin" }]
  }
}
```

**Pros**: Better IDE experience, no generated files to manage
**Cons**: Requires additional tooling, more complex implementation

**Decision**: Deferred. IDE integration remains an open design question (see Future Work). The runtime transformation works; IDE support can be addressed separately.

### 5. Standalone Binary Distribution

Distribute the CLI as a standalone binary with Bun runtime embedded:

```bash
curl -fsSL https://thinkwell.dev/install.sh | bash
```

**Pros**: Single binary with no dependencies, good for CI/CD environments
**Cons**: Larger download (~50MB), more complex release process

**Decision**: Deferred. npm distribution is sufficient for initial release. Standalone binaries can be added later for CI/CD use cases.

### 6. Namespace-Scoped Imports

Place the `import type` statement inside the generated namespace to avoid polluting the module scope:

```typescript
namespace Greeting {
  import type { SchemaProvider, JsonSchema } from "@thinkwell/acp";
  export const Schema: SchemaProvider<Greeting> = { ... };
}
```

**Pros**: No risk of name collisions with user code
**Cons**: TypeScript prohibits import declarations inside namespaces that reference external modules (error TS1147)

**Decision**: Rejected due to TypeScript language constraints. Instead, we use a mangled namespace import (`$$__thinkwell__acp__$$`) at module scope to minimize collision risk.

## Package Structure

```
packages/
  bun-plugin/              # @thinkwell/bun-plugin
    src/
      index.ts             # Plugin entry point
      transform.ts         # AST utilities for finding @JSONSchema types
      codegen.ts           # Code generation for namespace injections
      schema-generator.ts  # Schema generation via ts-json-schema-generator
      schema-cache.ts      # Mtime-based caching layer
      program-cache.ts     # TypeScript program caching
      declarations.ts      # .d.ts file generation (for future IDE integration)
      watcher.ts           # File watcher for --watch mode (for future IDE integration)
      modules.ts           # thinkwell:* module mappings
      errors.ts            # Error types and diagnostic formatting
    package.json
    README.md

  cli/                     # @thinkwell/cli
    bin/
      thinkwell            # Node.js launcher that delegates to Bun
    src/
      types-command.ts     # Implementation of `thinkwell types` (experimental)
    package.json           # depends on @thinkwell/bun-plugin
    README.md
```

## Security Considerations

- **File access**: Plugin only reads files Bun would already load
- **Code injection**: Injected code is deterministic from type definitions
- **No network**: All processing is local

## Testing Strategy

1. **Unit tests**: Schema generation, namespace injection
2. **Integration tests**: Full plugin with Bun.build
3. **Snapshot tests**: Verify output for various type patterns
4. **Comparison tests**: Ensure parity with build-schema-providers output

## Error Handling

The plugin uses fail-fast semantics with Rust/Cargo-style diagnostic formatting. Each error includes:
- An error code and summary on the first line
- Source location with file path and line number
- Quoted source context with line numbers
- Carets pointing to the relevant code
- A `help:` line with actionable fix suggestions

### Error Format

Errors follow a format inspired by Rust's compiler diagnostics:

```
error[E0001]: type `Foo` not found
 --> src/example.ts:2:1
  |
1 | /** @JSONSchema */
2 | interface Foo {
  | ^^^^^^^^^^^^^
  |
help: ensure the type is exported: `export interface Foo`
```

### ANSI Color Scheme

When output is a TTY, errors use ANSI colors for visual clarity:

| Element | Color | Style |
|---------|-------|-------|
| `error[E0001]:` | Red | Bold |
| Error message | White | Bold |
| Arrow (`-->`) | Bright Blue | Bold |
| File path | Default | Normal |
| Gutter (line numbers, `\|`) | Bright Blue | Bold |
| Source code | Default | Normal |
| Carets (`^^^`) | Yellow | Bold |
| `help:` | Green | Bold |
| Help message | Default | Normal |
| Inline code in help | Cyan | Normal |

### Error Codes

Each error type has a unique code for searchability and documentation:

| Code | Error Type |
|------|------------|
| E0001 | Type not found |
| E0002 | Circular type reference |
| E0003 | Unresolved generic type parameter |
| E0004 | Function type not representable in JSON Schema |
| E0005 | Symbol type not representable in JSON Schema |
| E0006 | BigInt type not representable in JSON Schema |
| E0007 | Complex conditional type |
| E0008 | Complex mapped type |
| E0009 | Template literal type cannot be enumerated |
| E0010 | TypeScript program creation failed |
| E0011 | File read error |
| E0012 | File write error |
| E0013 | Transpilation error (syntax error) |
| E0014 | Unknown thinkwell:* module |

### Source Context

The error formatter extracts source context by:
1. Reading the source file (already available during plugin execution)
2. Using the type's start position from the TypeScript AST
3. Showing 1-2 lines of context above the error line
4. Underlining the type name or declaration with carets

### Implementation Notes

The error formatting is implemented in `errors.ts` with:
- A `formatDiagnostic()` function that produces the formatted output
- TTY detection via `process.stdout.isTTY` to enable/disable colors
- Source location extraction from TypeInfo (already captured during parsing)
- Error codes as static properties on each error class

This approach ensures users immediately see problems with clear context rather than wading through verbose stack traces. The format is familiar to developers who use Rust, TypeScript, or other modern compilers.

## Future Work

### Additional CLI Commands

The `thinkwell` CLI could grow to include:

- **`thinkwell build`** - Bundle for production with pre-generated schemas, eliminating runtime startup latency. This is the production optimization path—`thinkwell` remains the primary development runtime regardless of project size.
- **`thinkwell init`** - Scaffold a new thinkwell project
- **`thinkwell check`** - Validate types and schemas without running

### IDE Integration

The runtime transformation works seamlessly when running code via `thinkwell`, but IDEs like VSCode don't know about these transformations. This creates several challenges:

1. **Namespace augmentation not recognized** - VSCode's TypeScript server doesn't see that `Greeting` has been augmented with a `.Schema` property, so `Greeting.Schema` shows as an error
2. **`thinkwell:*` URI scheme unknown** - Custom import schemes like `thinkwell:agent` are not recognized by the TypeScript language service
3. **Missing project configuration** - Scripts without `tsconfig.json` don't get proper type checking for Node/Bun globals

#### Potential Solutions

**TypeScript Language Service Plugin** - A TS plugin (`@thinkwell/ts-plugin`) could provide IDE support without runtime changes:

```json
// tsconfig.json
{
  "compilerOptions": {
    "plugins": [{ "name": "@thinkwell/ts-plugin" }]
  }
}
```

This would:
- Resolve `thinkwell:*` imports to their type definitions
- Provide virtual declarations for `Type.Schema` on `@JSONSchema`-annotated types
- Work transparently without generating files

**VSCode Extension** - A dedicated extension could:
- Handle `thinkwell:*` import resolution
- Auto-generate type declarations on file save
- Provide a status bar indicator for thinkwell projects

**Generated Declaration Files** - The current `thinkwell types` command generates `.thinkwell.d.ts` files, but this approach has UX issues:
- Files are littered alongside source files
- Must be manually run or integrated into a watch process
- Generated files would be committed to git and published to npm by default unless properly gitignored

The TS plugin approach is the most seamless but requires more implementation effort. This remains an open design question for future work.

### Node.js Runtime Support

While this RFD focuses on Bun as the primary runtime, Node.js support is technically feasible using Node's experimental module hooks API (`registerHooks` from `node:module`). This section documents the investigation and potential implementation strategy.

#### What's Portable

Most of the core plugin logic is already Node.js-compatible:

- **Schema generation** (`ts-json-schema-generator`) - Pure Node.js library
- **TypeScript AST parsing** (`typescript` compiler API) - Works in Node.js
- **Code generation and injection** - Pure string manipulation
- **Program caching** - Uses `node:fs` and `node:path`

#### Bun-Specific APIs Requiring Replacement

| Bun API | Node.js Equivalent |
|---------|-------------------|
| `Bun.Transpiler` | `esbuild.transformSync()` or `swc` |
| `Bun.file(path).text()` | `fs.readFileSync(path, 'utf-8')` |
| `Bun.file(path).stat()` | `fs.statSync(path)` |
| `plugin()` from "bun" | `registerHooks()` from "node:module" |

#### Node.js Loader Implementation Sketch

```javascript
// @thinkwell/node-loader
import { registerHooks } from 'node:module';
import { readFileSync, statSync } from 'node:fs';
import { fileURLToPath } from 'node:url';
import esbuild from 'esbuild';

// Reuse portable modules from bun-plugin
import { findMarkedTypes } from './transform.js';
import { generateSchemas } from './schema-generator.js';
import { generateInsertions, generateImport, applyInsertions } from './codegen.js';
import { THINKWELL_MODULES } from './modules.js';

registerHooks({
  resolve(specifier, context, nextResolve) {
    if (specifier.startsWith('thinkwell:')) {
      const moduleName = specifier.slice(10);
      const npmPackage = THINKWELL_MODULES[moduleName];
      if (npmPackage) {
        return nextResolve(npmPackage, context);
      }
    }
    return nextResolve(specifier, context);
  },

  load(url, context, nextLoad) {
    if (!url.endsWith('.ts') && !url.endsWith('.tsx')) {
      return nextLoad(url, context);
    }

    const filePath = fileURLToPath(url);
    let source = readFileSync(filePath, 'utf-8');

    // Rewrite thinkwell:* imports
    source = rewriteThinkwellImports(source);

    // Check for @JSONSchema
    if (!source.includes('@JSONSchema')) {
      const js = esbuild.transformSync(source, { loader: 'ts' }).code;
      return { source: js, format: 'module', shortCircuit: true };
    }

    // Generate schemas and inject
    const types = findMarkedTypes(filePath, source);
    const schemas = generateSchemas(filePath, types);
    const insertions = generateInsertions(types, schemas);
    let modified = applyInsertions(source, insertions);
    modified = generateImport() + '\n' + modified;

    const js = esbuild.transformSync(modified, { loader: 'ts' }).code;
    return { source: js, format: 'module', shortCircuit: true };
  }
});
```

#### CLI Runtime Selection Strategy

When adding Node.js support to the CLI, there are several options for selecting which runtime to use:

**Option 1: Autodetect**

The CLI automatically detects which runtimes are available and selects one:
- If running under Bun (detected via `process.versions.bun`), use Bun
- If running under Node.js and Bun is installed, prefer Bun
- If only Node.js is available, use the Node.js loader

Pros: Zero configuration, "just works"
Cons: May surprise users if behavior differs between environments

**Option 2: Environment Variable with Bun Default**

Use an environment variable (e.g., `THINKWELL_RUNTIME`) to explicitly select the runtime:
- `THINKWELL_RUNTIME=bun` - Use Bun (requires Bun installed)
- `THINKWELL_RUNTIME=node` - Use Node.js with the node-loader
- If unset, default to Bun (error if not installed)

Pros: Explicit, predictable, easy to configure in CI/CD
Cons: Requires configuration for Node.js users

**Option 3: Hybrid (Recommended)**

Combine Options 1 and 2:
- `THINKWELL_RUNTIME=bun` - Use Bun
- `THINKWELL_RUNTIME=node` - Use Node.js
- `THINKWELL_RUNTIME=auto` - Autodetect (Option 1 behavior)
- If unset, default to Bun

This provides explicit control when needed while allowing autodetection as an opt-in feature.

#### Trade-offs

| Factor | Bun | Node.js |
|--------|-----|---------|
| TypeScript support | Native | Requires esbuild/swc |
| Performance | Fast | ~20-50% slower |
| API stability | Stable | `registerHooks` is experimental |
| Deployment | Requires Bun | More universally available |

#### Alternative: Build-Time Only for Node.js

Instead of full runtime support, Node.js users could use a build-time workflow:
- Run `thinkwell build` (or existing `build-schema-providers`) to pre-generate schemas
- Execute the built output with plain Node.js

This mirrors how most TypeScript tooling works with Node.js today.

#### Recommendation

Implement Node.js runtime support in a follow-up PR with:
1. A new `@thinkwell/node-loader` package sharing code with `bun-plugin`
2. Option 3 (hybrid) runtime selection in the CLI
3. Documentation for both runtime and build-time Node.js workflows

## References

- [Bun Plugin API](https://bun.sh/docs/bundler/plugins)
- [Bun Runtime Plugins](https://bun.sh/docs/runtime/plugins)
- [Bun Build --compile](https://bun.sh/docs/bundler/executables)
- [Node.js Module Customization Hooks](https://nodejs.org/api/module.html#customization-hooks)
- [ts-json-schema-generator](https://github.com/vega/ts-json-schema-generator)
- [TypeScript Compiler API](https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API)
- [TypeScript-Go Issue #516: Transformer Plugin Support](https://github.com/microsoft/typescript-go/issues/516)
- [RFD: Schema Provider Interface](./schema-providers.md)
